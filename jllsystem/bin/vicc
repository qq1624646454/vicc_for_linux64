#!/bin/bash
#Copyright(c) 2015-2100.  jielong.lin.   All rights reserved.
#
# Version: R20170717
#
function Lfn_Product_RevisionInformation()
{
cat >&1 << EOF
# LIBRARY_REVISION:
#         LR.2015.09.25.V000 - Created by jielong.lin 
#         LR.2015.10.03.V000 - Modified by jielong.lin
#             Re-built all function and all names accord with the specified standard. 
#         LR.2015.10.11.V000 - Modified by jielong.lin
#             Implement Lfn_Sys_Rotate for progress bar. 
#         LR.2017.7.16.V000 - Modified by jielong.lin
#             Implement Lfn_Sys_Rotate_With_SIGNAL for progress bar.
#             Update Fn_vimide_Progressbar_MonitorByte for killing background process by signal 12 
# 
# APPLICATION_REVISION:
#         AR.`date +%Y.%M.%D`.V000 - Created by jielong.lin 
#         AR.2015.10.03.V000 - Modified by jielong.lin
#             Implement the three choice for Ui CheckBox, as follows:
#         AR.2015.10.04.V001 - Modified by jielong.lin
#             Modified the hint about "un-install.sh" to "uninstall.sh" 
#         AR.2015.10.04.V002 - Modified by jielong.lin
#             Modified the Lfn_Sys_FuncComment for "Error LineNo"
#         AR.2015.10.07.V000 - Modified by jielong.lin
#             Implement the PathView/Core/*.sh to run by first priority 
#
# SPECIFICATION:
#         Lfn***       - Library Function Name
#         Fn***        - Function Name
#         Lv***        - Library Function Variable Name
#         Cv***        - Constant Variable Name
#         Lfn_Tpv_***  - TPV Library Function Name
#
EOF
}

#------------------------------
# Constant Variable Definition
#------------------------------
CvPathFileForScript="`which $0`"
CvScriptName="`basename  ${CvPathFileForScript}`"
CvScriptPath="`dirname   ${CvPathFileForScript}`"

if [ x"$CvScriptPath" = x"." ]; then
    CvScriptPath="`pwd`"
fi



#------------------------------
# Library Functions Definition
#------------------------------

function Lfn_Product_Copyright_C()
{
cat >&1 << EOF
--------------------------------------------------------------
# Copyright (c) `date +%Y`. jielong.lin,  All rights reserved.
# ScriptPATH:  ${CvScriptPath}
# ScriptName:  ${CvScriptName}

EOF
}
########Lfn_Product_Copyright_C

function Lfn_Sys_DbgEcho()
{
    LvSdeCallerFileLineNo=`caller 0 | awk '{print $1}'`
    LvSdeCallerFuncName="${FUNCNAME[1]}"
    if [ -z "$1" -o x"$1" = x"" ]; then
        echo "[jll] ${LvSdeCallerFileLineNo},${LvSdeCallerFuncName}"
    else
        echo "[jll] ${LvSdeCallerFileLineNo},${LvSdeCallerFuncName}: $1"
    fi
}


## Usage:
##     Lfn_Sys_FuncComment 
function Lfn_Sys_FuncComment()
{
    LvSfcCallerFunc="${FUNCNAME[1]}"
    LvSfcCallerFileLineNo=`caller 0 | awk '{print $1}'`
    LvSfcPattern="function ${LvSfcCallerFunc}"
    LvSfcLineNo=`grep -Enwr  "^${LvSfcPattern}" ${CvScriptPath}/${CvScriptName} | awk -F ':' '{print $1}'`
    if [ -z "${LvSfcLineNo}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Return due to the bad function format" 
        return;
    fi

    LvSfcCnt=0
    for LvSfcIdx in ${LvSfcLineNo}; do
        LvSfcCnt=`expr ${LvSfcCnt} + 1`
    done
    if [ ${LvSfcCnt} -ne 1 -o ${LvSfcLineNo} -lt 0 ]; then
        Lfn_Sys_DbgEcho "Sorry, exit due to the invalid function comment format" 
        exit 0
    fi
    LvSfcContentLineNo=`expr ${LvSfcLineNo} - 1`
    if [ ${LvSfcContentLineNo} -lt 0 ]; then
        return;
    fi
    LvSfcContentStartLineNo=${LvSfcContentLineNo} 
    LvSfcContentEndLineNo=${LvSfcContentLineNo}

    while [ ${LvSfcContentStartLineNo} -ne 0 ]; do 
        LvTempContent=`sed -n "${LvSfcContentStartLineNo}p" ${CvScriptPath}/${CvScriptName} | grep -Ewn "^##"`
        if [ -z "${LvTempContent}" ]; then
            break;
        fi
        LvSfcContentStartLineNo=`expr ${LvSfcContentStartLineNo} - 1`
    done
 
    if [ ${LvSfcContentStartLineNo} -lt ${LvSfcContentEndLineNo} ]; then
        echo "Error LineNo : ${LvSfcCallerFileLineNo}"
        LvSfcContentStartLineNo=`expr ${LvSfcContentStartLineNo} + 1`
        sed -n "${LvSfcContentStartLineNo},${LvSfcContentEndLineNo}p" ${CvScriptPath}/${CvScriptName} | sed 's/^#\{0,\}//'
    fi
    return;
}



## Usage:
##     Lfn_Sys_CheckRoot
## Details:
##     If the current user isn't root, then exit directly.
function Lfn_Sys_CheckRoot()
{
    if [ x"`whoami`" != x"root" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to invalid root privilege"
        exit 0
    fi
    return;
}


## Usage:
##     Lfn_Sys_GetAllUsers <oResult> 
## Details:
##     Get all users and output the result to <oResult> 
## Example:
##     Lfn_Sys_GetAllUsers oUserList 
##     for oUser in ${oUserList}; do
##         echo "User:${oUser}"
##     done 
function Lfn_Sys_GetAllUsers()
{
    if [ $# -ne 1 ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to the fatal parameter error" 
        exit 0; 
    fi
    LvSgauResult="root"
    LvSgauUsers=`cd /home/;find . -maxdepth 1 -a \( -path "./xmic" -o -path "./.*" -o -path "./lost+found" \)  -prune -o -type d -a -print | sed "1d"`
    LvSgauRegUsers=`cat /etc/passwd | awk -F: '$3>=500' | cut -f 1 -d :`
    # Access every user in /home 
    for LvSgauUser in ${LvSgauUsers}; do
        for LvSgauRegUser in ${LvSgauRegUsers}; do
            if [ x"./${LvSgauRegUser}" = x"${LvSgauUser}" ]; then
                LvSgauResult="${LvSgauResult} ${LvSgauRegUser}" 
            fi
        done
    done
    LvSgauResult=`echo ${LvSgauResult} | sed 's:\ :\\\ :g'`
    eval $1="${LvSgauResult}"
}


  #----------------------------------
  # ANSI Control Code
  #----------------------------------
  #   \033[0m 关闭所有属性
  #   \033[01m 设置高亮度
  #   \033[04m 下划线
  #   \033[05m 闪烁
  #   \033[07m 反显
  #   \033[08m 消隐
  #   \033[30m -- \033[37m 设置前景色
  #   \033[40m -- \033[47m 设置背景色
  #   \033[nA 光标上移n行
  #   \033[nB 光标下移n行
  #   \033[nC 光标右移n行
  #   \033[nD 光标左移n行
  #   \033[y;xH 设置光标位置
  #   \033[2J 清屏
  #   \033[K  清除从光标到行尾的内容
  #   \033[s  保存光标位置
  #   \033[u  恢复光标位置
  #   \033[?25l 隐蔽光标
  #   \033[?25h 显示光标
  #-----------------------------------


  # 黑:Black
  # 红:Red
  # 绿:Green
  # 黄:Yellow
  # 蓝:Blue
  # 粉红:Pink
  # 海蓝:SeaBlue
  # 白:White

CvAccOff="\033[0m"

CvFgBlack="\033[30m"
CvFgRed="\033[31m"
CvFgGreen="\033[32m"
CvFgYellow="\033[33m"
CvFgBlue="\033[34m"
CvFgPink="\033[35m"
CvFgSeaBule="\033[36m"
CvFgWhite="\033[37m"

CvBgBlack="\033[40m"
CvBgRed="\033[41m"
CvBgGreen="\033[42m"
CvBgYellow="\033[43m"
CvBgBlue="\033[44m"
CvBgPink="\033[45m"
CvBgSeaBule="\033[46m"
CvBgWhite="\033[47m"


## Usage:
##     Lfn_Sys_DbgColorEcho [CvFgXxx|CvBgXxx] [CvFgXxx|CvBgXxx] [TEXT] 
## Details:
##     Print the format <TEXT> with fg-color named [CvFgXxx] or bg-color named [CvBgXxx]
## Parameter:
##     [CvFgXxx]   - Foreground color
##     [CvBgXxx]   - Background color 
##     [TEXT] - The text to display on the standard output device.
## Example:
##     Lfn_Sys_DbgColorEcho ${CvFgRed} ${CvBgWhite} "hello World"
##
function Lfn_Sys_DbgColorEcho()
{
    LvSdceCallerFileLineNo=`caller 0 | awk '{print $1}'`
    LvSdceCallerFuncName="${FUNCNAME[1]}"

    LvSdceFgColor=""
    LvSdceBgColor=""
    LvSdceText=""

    while [ $# -ne 0 ]; do
    case $1 in
    "\033[3"*)
        if [ -z "${LvSdceFgColor}" ]; then
            LvSdceFgColor=$1
        fi
        ;;
    "\033[4"*)
        if [ -z "${LvSdceBgColor}" ]; then
            LvSdceBgColor=$1
        fi
        ;;
    *)
        if [ -z "${LvSdceText}" ]; then
            LvSdceText=$1
        fi 
        ;;
    esac
    shift
    done

    if [ -z "${LvSdceText}" ]; then 
        echo -e "${CvAccOff}${LvSdceFgColor}${LvSdceBgColor}"\
                "\b[jll] ${LvSdceCallerFileLineNo},${LvSdceCallerFuncName}${CvAccOff}" 
    else
        echo -e "${CvAccOff}${LvSdceFgColor}${LvSdceBgColor}"\
                "\b[jll] ${LvSdceCallerFileLineNo},${LvSdceCallerFuncName}: ${LvSdceText}${CvAccOff}" 
    fi
}


## Usage:
##     Lfn_Sys_ColorEcho [CvFgXxx|CvBgXxx] [CvFgXxx|CvBgXxx] [TEXT] 
## Details:
##     Print the format <TEXT> with fg-color named [CvFgXxx] or bg-color named [CvBgXxx]
## Parameter:
##     [CvFgXxx]   - Foreground color
##     [CvBgXxx]   - Background color 
##     [TEXT] - The text to display on the standard output device.
## Example:
##     Lfn_Sys_ColorEcho ${CvFgRed} ${CvBgWhite} "hello World"
##
function Lfn_Sys_ColorEcho()
{
    LvSceFgColor=""
    LvSceBgColor=""
    LvSceText=""

    while [ $# -ne 0 ]; do
    case $1 in
    "\033[3"*)
        if [ -z "${LvSceFgColor}" ]; then
            LvSceFgColor=$1
        fi
        ;;
    "\033[4"*)
        if [ -z "${LvSceBgColor}" ]; then
            LvSceBgColor=$1
        fi
        ;;
    *)
        if [ -z "${LvSceText}" ]; then
            LvSceText=$1
        fi 
        ;;
    esac
    shift
    done

    echo -e "${CvAccOff}${LvSceFgColor}${LvSceBgColor}${LvSceText}${CvAccOff}" 
}


## Usage:
##     Lfn_Sys_GetEachUpperLevelPath <oPaths>
## Details:
##     Get the each level path towards upper 
## Parameter:
##     oPaths - output each level paths 
## Example:
##     Lfn_Sys_GetEachUpperLevelPath oPaths 
##     OldIFS=$IFS
##     IFS=:
##     for My_Path in $My_Paths; do
##         echo "--> $My_Path"
##     done
##     IFS=$OldIFS
##
function Lfn_Sys_GetEachUpperLevelPath()
{
    if [ -z "$1" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    LvGadoulPaths=""
    LvGadoulPath=`pwd`
    while [ ! -z "${LvGadoulPath}" ]; do
        if [ -z "${LvGadoulPaths}" ]; then
            LvGadoulPaths="${LvGadoulPath}"
        else
            LvGadoulPaths="${LvGadoulPaths}:${LvGadoulPath}"
        fi

        LvGadoulBasename=`basename "${LvGadoulPath}"`
        LvGadoulPath=`echo "${LvGadoulPath}" | sed "s/\/${LvGadoulBasename}//"`
    done

    LvGadoulPaths=`echo "${LvGadoulPaths}" | sed "s/\ /\\\\\ /g"`
    if [ -z "${LvGadoulPaths}" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    eval $1="${LvGadoulPaths}"
}


## Usage:
##     Lfn_Sys_GetSameLevelPath <oPaths> <iKeywordString>
## Details:
##     Get the path on the same level path with <iKeywordString> from the parent path
##     based on the current path
## Parameter:
##     oPaths - output the specified path
## Example:
##     Lfn_Sys_GetSameLevelPath  oResult ".repo frameworks dalvik libnativehelper"
##     if [ ! -z "${oResult}" ]; then
##         echo "${oResult}"
##     fi
##
function Lfn_Sys_GetSameLevelPath()
{
    if [ $# -ne 2 -o -z "$2" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    LvSgslpKeywords="$2"
    eval $1=""

    # visit every location from the tails of the current path
    Lfn_Sys_GetEachUpperLevelPath LvSgslpPaths
    OldIFS=$IFS
    IFS=:
    for LvSgslpPath in ${LvSgslpPaths}; do
        IFS=$OldIFS
        for LvSgslpKey in ${LvSgslpKeywords}; do
            LvSgslpFlag=`ls -a ${LvSgslpPath} | grep -iw "${LvSgslpKey}"`
            if [ ! -z "${LvSgslpFlag}" ]; then
                continue
            fi
            break
        done

        if [ ! -z "${LvSgslpFlag}" ]; then
            LvSgslpPath=`echo "${LvSgslpPath}" | sed "s/\ /\\\\\ /g"`
            eval $1="${LvSgslpPath}"
            IFS=$OldIFS
            return 0
        fi
        IFS=:
    done
    IFS=$OldIFS

    return 0
}


## Lfn_Sys_Rotate &
## GvBgPid=$!
## sleep 20
## kill -9 ${GvBgPid} 
##
function Lfn_Sys_Rotate()
{
    LvSrInterval=0.05
    LvSrTcount="0"

    while true; do
        LvSrTcount=`expr ${LvSrTcount} + 1`
        case  ${LvSrTcount}  in
        1)
            echo -ne "\b-"
            sleep  ${LvSrInterval}
        ;;
        2)
            echo -ne "\b\\"
            sleep  ${LvSrInterval}
        ;;
        3)
            echo -ne "\b|"
            sleep  ${LvSrInterval}
        ;;
        4)
            echo -ne "\b/"
            sleep  ${LvSrInterval}
        ;;
        *)
            LvSrTcount="0"
            sleep  ${LvSrInterval}
        ;;
        esac
    done
}

## Lfn_Sys_Rotate_With_SIGNAL
## GvBgPid=$!
## sleep 20
## kill -12 ${GvBgPid} 
##
function Lfn_Sys_Rotate_With_SIGNAL()
{
    LvSrInterval=0.05
    LvSrTcount="0"

    export __jllutil_rotate_status=1

    # When SIGUSR2(=12) is received, run "export __jllutil_rotate_status=0" 
    trap "export __jllutil_rotate_status=0"  12

    while [ x"${__jllutil_rotate_status}" = x"1" ]; do
        LvSrTcount=`expr ${LvSrTcount} + 1`
        case  ${LvSrTcount}  in
        1)
            echo -ne "\b-"
            sleep  ${LvSrInterval}
        ;;
        2)
            echo -ne "\b\\"
            sleep  ${LvSrInterval}
        ;;
        3)
            echo -ne "\b|"
            sleep  ${LvSrInterval}
        ;;
        4)
            echo -ne "\b/"
            sleep  ${LvSrInterval}
        ;;
        *)
            LvSrTcount="0"
            sleep  ${LvSrInterval}
        ;;
        esac
    done

    trap 12 # Restore signal SIGUSR2 to default action.
}





## Usage: 
##     Lfn_Tpv_GetSoftwareVersion <oProjVer>
## Details:
##     Get the software version of the EU2k15 MTK project
## Parameter:
##     <oProjVer> - the output buffer of the project version. Failure if oProjVer is "NULL"
## Note:
##     TARGET_PRODUCT should be set before this function is called.
## Example:
##     Lfn_Tpv_GetSoftwareVersion  oProjVer
##     echo "FwVersion: $oProjVer"
##
function Lfn_Tpv_GetSoftwareVersion()
{
    if [ $# -ne 1 ]; then
        Lfn_Sys_FuncComment
        return 0
    fi

    eval $1="NULL"

    #Get the Android root
    Lfn_Sys_GetSameLevelPath LvTgsvRootPath ".repo frameworks dalvik libnativehelper"
    if [ -z "${LvTgsvRootPath}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont find the root path from current by towards upper"
        exit 0
    fi

    if [ -z "$TARGET_PRODUCT" ]; then

        LvTgsvTargetProduct="`ls ${LvTgsvRootPath}/device/tpvision | grep -Er 'philips_MT5593*'`"
        if [ -z "${LvTgsvTargetProduct}" ]; then
            Lfn_Sys_DbgEcho "Sorry, Return because dont find the philips_MT5593* in ${LvTgsvRootPath}/device/tpvision"
            return; 
        fi

        while [ ! -z "${LvTgsvTargetProduct}" ]; do
            echo "Please select the choice from the following menu:"
            echo ""
            echo " (Menu)      (Detail) "
            echo "    0         quit"
            LvTgsvIdx=1
            for LvTgsvTP in ${LvTgsvTargetProduct}; do
                echo "    ${LvTgsvIdx}         ${LvTgsvTP}"
                LvTgsvIdx=`expr ${LvTgsvIdx} + 1`
            done
            read -p "Your Choice: " LvTgsvChoice
            if [ ${LvTgsvChoice} -eq 0 ]; then
                return;
            fi
            if [ ${LvTgsvChoice} -gt ${LvTgsvIdx} -o ${LvTgsvChoice} -eq ${LvTgsvIdx} ]; then
                echo "Error, try it again"
                continue;
            fi
            LvTgsvIdx=1
            for LvTgsvTP in ${LvTgsvTargetProduct}; do
                if [ x"${LvTgsvIdx}" = x"${LvTgsvChoice}" ]; then  
                    TARGET_PRODUCT="${LvTgsvTP}"
                    break;
                fi
                LvTgsvIdx=`expr ${LvTgsvIdx} + 1`
            done
            if [ ! -z "${TARGET_PRODUCT}" ]; then
                break;
            fi
        done
    fi
 
    if [ ! -e "${LvTgsvRootPath}/device/tpvision/${TARGET_PRODUCT}/system.prop" ]; then
        Lfn_Sys_DbgEcho "Sorry, Return because dont exist \"${LvTgsvRootPath}/device/tpvision/${TARGET_PRODUCT}/system.prop\""
        return;
    fi

    LvTgsvSoftwareVersion="`cat ${LvTgsvRootPath}/device/tpvision/${TARGET_PRODUCT}/system.prop \
                             | grep -i product.swversion | awk -F '=' '{print $2}'`"
    if [ ! -z "${LvTgsvSoftwareVersion}" ]; then
        eval $1="${LvTgsvSoftwareVersion}"
    else
        Lfn_Sys_DbgEcho "Sorry, Dont find version" 
    fi
    return;
}



## Usage: 
##     Lfn_Tpv_GetGitTagVersion <oProjVer>
## Details:
##     Get the git tag version of the EU2k15 MTK project
## Parameter:
##     <oProjVer> - the output buffer of the project version. Failure if oProjVer is "NULL"
## Example:
##        Lfn_Tpv_GetGitTagVersion oProjVer 
##        echo "GitTagVersion: $oProjVer"
## 
function Lfn_Tpv_GetGitTagVersion() 
{
    if [ $# -ne 1 ]; then
        Lfn_Sys_FuncComment
        return 0
    fi

    eval $1="NULL"

    Lfn_Tpv_GetSoftwareVersion LvTggtvFwVer  
    if [ -z "${LvTggtvFwVer}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Return because dont get the version"
        return 0 
    fi

    LvTggtvGitTagVersion=`echo ${LvTggtvFwVer} | sed "s/E\./E_R/"`
    if [ ! -z "${LvTggtvGitTagVersion}" ]; then
        eval $1="${LvTggtvGitTagVersion}" 
    fi
    return 0
}



CvCodeFileTable0="*"
CvCodeFileTable1="*.c *.java *.cpp *.cxx *.aidl *.h *.hpp *.hxx *.cc *.s *.S *.lds *.mak Makefile makefile"
CvCodeFileTable2="*.c *.java *.cpp *.cxx *.aidl *.h *.hpp *.hxx *.cc *.s *.S"
CvCodeFileTable3="*.c *.cpp *.cxx *.h *.hpp *.hxx *.cc"
CvCodeFileTable4="*.java *.aidl *.h "

## Usage:
##     Lfn_File_SearchSymbol -S <SYMBOL>  -F <ScopeFiles...> -M <MatchMode>
## Details:
##     Search the <SYMBOL> from <ScopeFiles...> as <MatchMode>
##     output the matched information. 
## Parameter:
##     <SYMBOL> - specified symbol used for matching search file location.
##     <ScopeFile> - specified the files used to be searched.
##     <MatchMode> - specified the matching as precise or comprehensive.
##                   one of the values:
##                   0 - precise (default)
##                   1 - comprehensive 
## Example:
##     Lfn_File_SearchSymbol --Symbol="main"  --File=*.c --File=*.java --File=*.cpp --Mode=0
##
function Lfn_File_SearchSymbol()
{
    CvPreciseFlags="-Fwnr"
    CvComprehensiveFlags="-Fnr"

    LvFssSymbol=""
    LvFssFile=""
    LvFssFileSwitch=1
    LvFssMode="0"
    LvFssFlags="${CvPreciseFlags}"

    while [ $# -ne 0 ]; do
    case $1 in
    --Symbol=*)
        if [ -z "${LvFssSymbol}" ]; then
            LvFssSymbol=`echo $1 | sed -e "s/--Symbol=//g" -e "s/,/ /g"`
        fi
        ;;
    --File=*)
        if [ x"${LvFssFileSwitch}" = x"1" ]; then
            LvFssTempFileString="`echo $1 | sed -e 's/--File=//g' -e 's/,/ /g'`"
            if [ x"${LvFssTempFileString}" = x"*" ]; then
                LvFssFile="*"
                LvFssFileSwitch=0
            else 
                if [ ! -z "${LvFssTempFileString}" ]; then
                    LvFssFile="${LvFssFile} ${LvFssTempFileString}"
                fi
            fi
        fi
        ;;
    --Mode=*)
        LvFssMode=`echo $1 | sed -e "s/--Mode=//g" -e "s/,/ /g"`
        ;;
    *)
        ;;
    esac
    shift
    done
    if [ -z "${LvFssSymbol}" -o -z "${LvFssFile}" ]; then
        Lfn_Sys_FuncComment
        return;
    fi

    if [ x"${LvFssMode}" = x"1" ]; then
        LvFssFlags=${CvComprehensiveFlags}
    fi

    for LvFssFl in ${LvFssFile}; do
        find `pwd` -type f -a -name "${LvFssFl}" -print | while read LvFssLine; do
            LvFssMatch=`grep ${LvFssFlags} "${LvFssSymbol}" "${LvFssLine}" --color=always`
            if [ x"$?" = x"0" ]; then
                Lfn_Sys_ColorEcho  ${CvFgBlack}  ${CvBgWhite}    " ${LvFssLine} "
                Lfn_Sys_ColorEcho  "${LvFssMatch}"
                echo
            fi
        done
    done
    echo
    Lfn_Sys_ColorEcho ${CvBgRed} ${CvFgYellow} " Done"
    echo
}



## Usage:
##     Lfn_File_DeleteMatchLine <iString>  <iFile>
## Details:
##     Delete the lines which are matched by the specified <iString> from file <iFile>
## Example:
##     Lfn_File_DeleteMatchLine "jielong.lin"  "./test"
##
function Lfn_File_DeleteMatchLine()
{
    if [ -z "$1" -o -z "$2" -o ! -e "$2" ]; then
        Lfn_Sys_FuncComment
        return 0
    fi
    LvFdmlString=$1
    LvFdmlFile=$2
    LvFdmlLines=`grep -Fwnr "${LvFdmlString}" "${LvFdmlFile}" | awk -F ':' '{print $1}'`
    LvFdmlIdx=0
    for LvFdmlLine in ${LvFdmlLines}; do
        LvFdmlLine=`expr ${LvFdmlLine} - ${LvFdmlIdx}`;
        sed "${LvFdmlLine}"d -i ${LvFdmlFile};
        echo "[GOOD] ${LvFdmlFile}:${LvFdmlLine} is delelted"
        LvFdmlIdx=`expr ${LvFdmlIdx} + 1`;
    done
}

## Usage:
##     Lfn_File_DeletePreciseMatchLine <iString>  <iFile>
## Details:
##     Delete the lines which are matched by the specified <iString> from file <iFile>
## Example:
##     Lfn_File_DeletePreciseMatchLine "/jie/long/"  "/home/jielong.lin/1.txt"
##
function Lfn_File_DeletePreciseMatchLine()
{
    if [ -z "$1" -o -z "$2" -o ! -e "$2" ]; then
        Lfn_Sys_FuncComment
        return
    fi
    LvFdpmlString="$1"
    LvFdpmlFile="$2"
    LvFdmlLines=$(grep -Fwnr "${LvFdpmlString}" "${LvFdpmlFile}" | awk -F ':' '{print $1}')
    LvFdpmlSets=$(grep -Fwr  "${LvFdpmlString}" "${LvFdpmlFile}")
    if [ -z "${LvFdpmlSets}" ]; then
    #    Lfn_Sys_DbgEcho "Sorry, Return Because dont find the match line"
        return
    fi

    declare -i LvFdpmlIdx=0
    declare -a LvFdpmlList
    for LvFdpmlEntry in ${LvFdpmlSets}; do
       LvFdpmlList[LvFdpmlIdx]="${LvFdpmlEntry}"
       LvFdpmlIdx=`expr ${LvFdpmlIdx} + 1`;
    done

    # for (( LvFdpmlIdx=0 ; LvFdpmlIdx<${#LvFdpmlList[@]} ; LvFdpmlIdx++ )) do
    #    echo "${LvFdpmlList[LvFdpmlIdx]}"
    # done

    LvFdpmlIdx=0
    for LvFdpmlLine in ${LvFdmlLines}; do
    #    echo "#${LvFdpmlList[LvFdpmlIdx]} #${LvFdpmlString}"
        if [ x"${LvFdpmlList[LvFdpmlIdx]}" = x"${LvFdpmlString}" ]; then
            LvFdpmlLine=$(expr ${LvFdpmlLine} - ${LvFdpmlIdx})
            sed "${LvFdpmlLine}"d -i ${LvFdpmlFile}
        fi
        LvFdpmlIdx=`expr ${LvFdpmlIdx} + 1`;
    done 

    unset LvFdpmlIdx
    unset LvFdpmlList
    unset LvFdpmlString
    unset LvFdpmlFile
}


## Usage: 
##     Lfn_File_BatchModifyFileName <iOld> <iNew>
## Details:
##     The file names which contain the <iOld> to <iNew> under the current path. 
## Parameter:
##     <iOld> - the pattern string as be replaced 
##     <iNew> - the target string. 
## Example:
##        Lfn_File_BatchModifyFileName "aaa" "bbb"
## 
function Lfn_File_BatchModifyFileName() 
{
    if [ $# -ne 2 ]; then
        Lfn_Sys_FuncComment
        return 0
    fi

    LvFbmfnFiles=`find . -type f`

    for LvFbmfnFile in ${LvFbmfnFiles}; do
        if [ "${LvFbmfnFile}" = "$0" ]; then
            continue
        fi
        LvFbmfnTargetFile=`echo ${LvFbmfnFile} | sed "s/$1/$2/g"`
        if [ "${LvFbmfnFile}" = "${LvFbmfnTargetFile}" ]; then
            continue
        else
            mv ${LvFbmfnFile} ${LvFbmfnTargetFile}
        fi
    done
}


## Usage:
##     Lfn_File_CheckIfExistSymbol <oResult> <iFlag> <iFile>
## Details:
##     Check if the file <iFile> has already contained the flag <iFlag>
##     If Contained, <oResult> is 1.
##     If Not Contain, <oResult> is 0. 
## Example:
##     iFlag="### Modification by Vanquisher for /etc/fstab ###"
##     Lfn_File_CheckIfExistSymbol oResult "$strFlag" "/etc/fstab"
##     if [ ${oResult} -eq 1 ]; then
##         echo "Modified"
##     else
##         echo "Un-modified"
##     fi
function Lfn_File_CheckIfExistSymbol()
{
    if [ $# -ne 3 ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to the fatal parameter error" 
        exit 0; 
    fi

    if [ -z "$2" -o -z "$3" -o ! -e "$3" ]; then
        Lfn_Sys_FuncComment
        eval $1="0"
        return; 
    fi

    LvFciesFlag=`grep -iwnr "$2" $3`  
    if [ -z "${LvFciesFlag}" ]; then
        eval $1="0"
    else
        eval $1="1" 
    fi
}



## Usage:
##     Lfn_File_GetMatchLine <oResult> <iKeyWord> <iFilePath>
## Details:
##     Get the Line Number of the File located in "<FilePath>" if "<KeyWord>" is
##     matched successfully. Save the result to <oResult>
## Parameter:
##     <iKeyWord> - specified string used for matching search file location.
##     <iFilePath> - specify the file path.
##     <oResult> - out the file line as the result.
## Example:
##     Lfn_File_GetMatchLine oFileLine "main" "/home/1.txt"
##     if [ ! -z "${oFileLine}" ]; then
##         echo "Line: ${oFileLine}"
##     fi
##
function Lfn_File_GetMatchLine()
{
    if [ -z "$1" -o -z "$2" -o -z "$3" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to error usage"
        Lfn_Sys_FuncComment
        exit 0
    fi  

    if [ ! -e "$3" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont exist \"$3\""
        exit 0
    fi  

    # LvFgmlKeyword is only single line, so it doesnt need to be contained by the single quotes.
    LvFgmlKeyword=$(echo -e "$2" | sed "s#\/#\\\/#g")
    LvFgmlKeyword=$(echo -e "${LvFgmlKeyword}" | sed "s:	:\\\\t:g")
    LvFgmlKeyword=$(echo -e "${LvFgmlKeyword}" | sed "s:\[:\\\[:g")
    LvFgmlKeyword=$(echo -e "${LvFgmlKeyword}" | sed "s:\]:\\\]:g")
    LvFgmlKeyword=$(echo -e "${LvFgmlKeyword}" | sed "s:\*:\\\*:g")

    # Maybe the result contains the break line, and it will cause
    # the error that cannt find command.
    # Transform the line break symbol to the one space symbol
    LvFgmlLineNo=""
    for LvFgmlLineNoItem in $(sed -n "/${LvFgmlKeyword}/=" $3); do
        if [ -z "${LvFgmlLineNo}" ]; then
            LvFgmlLineNo="${LvFgmlLineNoItem}"
        else
            LvFgmlLineNo="${LvFgmlLineNo} ${LvFgmlLineNoItem}"
        fi
    done
    # Space is not recognised in the eval command. So it should be transferred.
    LvFgmlLineNo=$(echo -e "${LvFgmlLineNo}" | sed "s:\ :\\\\ :g")
#    if [ -z "${LvFgmlLineNo}" ]; then
#        Lfn_Sys_DbgEcho "Sorry, Dont find the line which is matched" 
#    fi  

    eval $1="${LvFgmlLineNo}"
}


## Usage:
##     Lfn_File_GetReverseMatchLine <oResult> <iKeyWord> <iFilePath>
## Details:
##     Get the Line Number of the File located in "<iFilePath>" if "<iKeyWord>" is
##     matched successfully.Then reverse the result and save it to <oResult> 
##
function Lfn_File_GetReverseMatchLine()
{
    Lfn_File_GetMatchLine LvFgrmlLines "$2" "$3"
    LvFgrmlLineSets=""
    for LvFgrmlLine in ${LvFgrmlLines}; do
        LvFgrmlLineSets="${LvFgrmlLine} ${LvFgrmlLineSets}"
    done
    LvFgrmlLines="${LvFgrmlLineSets}"
    LvFgrmlLines=`echo ${LvFgrmlLines} | sed 's#\ #\\\ #g'`
    eval $1="${LvFgrmlLines}"
}


##
## Usage:
##     Lfn_File_GetFirstFullMatchLine oFileLine "/home/jielong.lin" "/home/jielong.lin/1.txt"
##     if [ ! -z "${oFileLine}" ]; then
##         echo "Line: ${oFileLine}"
##     fi
##
function Lfn_File_GetFirstFullMatchLine()
{
    if [ -z "$1" -o -z "$2" -o -z "$3" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to error usage"
        Lfn_Sys_FuncComment
        exit 0
    fi

    if [ ! -e "$3" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont exist \"$3\""
        exit 0
    fi

    LvFgfmlSet=$(grep -wn "$2" "$3" | awk -F ':' '{print $1}')
    if [ -z "${LvFgfmlSet}" ]; then
        eval $1=""
        return
    fi
    declare -a LvFgfmlLines
    declare -i LvFgfmlCnt=0
    declare -i LvFgfmlId=0
    for LvFgfmlLineNo in ${LvFgfmlSet}; do
        LvFgfmlLines[LvFgfmlId]=${LvFgfmlLineNo}
        LvFgfmlId=$(expr ${LvFgfmlId} + 1)
    done
    LvFgfmlCnt=${#LvFgfmlLines[@]}

    LvFgfmlList=$(grep -w "$2" "$3")
    LvFgfmlId=0
    for LvFgfmlItem in ${LvFgfmlList}; do
        if [ x"${LvFgfmlItem}" = x"$2" ]; then
           break;
        fi
        LvFgfmlId=$(expr ${LvFgfmlId} + 1)
    done
    if [ LvFgfmlId != LvFgfmlCnt ]; then
        eval $1=${LvFgfmlLines[LvFgfmlId]}
        unset LvFgfmlLines
        unset LvFgfmlCnt
        unset LvFgfmlId
        return;
    fi
    unset LvFgfmlLines
    unset LvFgfmlCnt
    unset LvFgfmlId
 
    eval $1=""
}


## Usage:
##     Lfn_File_GetFileTailLine <oResult> <iFile>
## Detail:
##     Get the line number at the end of the file.
## Exmaple:
##     Lfn_File_GetFileTailLine oResult  "~/1.txt"
##     echo "EndLine: ${oResult}"
function Lfn_File_GetFileTailLine()
{
    if [ -z "$2" -o ! -e "$2" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont exist \"$2\""
        exit 0
    fi

    LvFgftlLineNo=`sed -n '$=' $2`
    eval $1="${LvFgftlLineNo}"
}



## Usage:
##     Lfn_File_InsertAfterMatchLine <iKeyWord> <iFile>  <iString>
## Details:
##     Insert the "<iString>" to the next line of the File located in "<iFile>"
##     if "<iKeyWord>" is matched successfully. Or Insert the "<iString>" to the
##     tail of the File.
## Parameter:
##     <iKeyWord> - specified string used for matching search file location.
##     <iFilePath> - specify the file path.
##     <iString> - specify the content which is inserted.  # Example:
## Example:
##     Lfn_File_InsertAfterMatchLine  "main" "/home/1.txt" "jielong.lin"
##
function Lfn_File_InsertAfterMatchLine()
{
    if [ -z "$1" -o -z "$2" -o -z "$3" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    if [ ! -e "$2" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont exist \"$2\""
        exit 0
    fi

    Lfn_File_GetReverseMatchLine  LvFiamlLines "$1" "$2"
    for LvFiamlLine in ${LvFiamlLines}; do
        sed "$LvFiamlLine a $3" -i $2
        Lfn_Sys_ColorEcho ${CvBgBlue}  ${CvFgWhite} "Done: insert at next line from ${LvFiamlLine}"
    done
    return
}

## Lfn_File_DownloadFromNet <URL>
function Lfn_File_DownloadFromNet()
{
    if [ -z "$1" -o x"$1" = x"" ]; then
        Lfn_Sys_DbgEcho "Sorry, exit due to the parameter is null"
        exit 0
    fi

    LvFdfnPathfile="$1"
    LvFdfnFile=`basename "${LvFdfnPathfile}"`
    wget -c ${LvFdfnPathfile} -O ${LvFdfnFile}
}



## Usage:
##     Lfn_Line_CheckIfExistSymbol <oResult> <iSymbol> <iContent>
##
## Details:
##     Return 1 if exist.
##     Return 0 if not exist.
##
## Sample:
##     Lfn_Line_CheckIfExistSymbol oResult  "main" "hello world, main entry"
##     echo "$oResult"
function Lfn_Line_CheckIfExistSymbol()
{
    if [ -z "$1" -o -z "$2" -o -z "$3" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to error usage"
        Lfn_Sys_FuncComment
        exit 0
    fi

    # LvCiseKeyword is only single line, so it doesnt need to be contained by the single quotes.
    LvCiseKeyword=$(echo -e "$2" | sed "s#\/#\\\/#g")
    LvCiseKeyword=$(echo -e "${LvCiseKeyword}" | sed "s:\t:\\\t:g")
    LvCiseKeyword=$(echo -e "${LvCiseKeyword}" | sed "s:\[:\\\[:g")
    LvCiseKeyword=$(echo -e "${LvCiseKeyword}" | sed "s:\]:\\\]:g")
    LvCiseKeyword=$(echo -e "${LvCiseKeyword}" | sed "s:\*:\\\*:g")

    # $3 isn't transition is used by echo command
    #LvCiseLine=$(echo -e "$3" | sed "s#\/#\\\/#g")
    #LvCiseLine=$(echo -e "${LvCiseLine}" | sed "s:\t:__:g")
    #LvCiseLine=$(echo -e "${LvCiseLine}" | sed "s:\[:\\\[:g")
    #LvCiseLine=$(echo -e "${LvCiseLine}" | sed "s:\]:\\\]:g")
    #LvCiseLine=$(echo -e "${LvCiseLine}" | sed "s:\*:\\\*:g")

    LvCiseResult=$(echo "$3" | sed -n "/${LvCiseKeyword}/=")
    if [ -z "${LvCiseResult}" ]; then
        eval $1="0"
    else
        eval $1="1"
    fi 
}



## Lfn_Cursor_EchoConfig [on|off] 
function Lfn_Cursor_EchoConfig()
{
    if [ -z "$1" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi
    if [ x"$1" = x"off" ]; then
        echo -e "${CvAccOff}\033[?25l${CvAccOff}"
    fi
    if [ x"$1" = x"on" ]; then
        echo -e "${CvAccOff}\033[?25h${CvAccOff}"
    fi
}


## Lfn_Cursor_Position <oXData> <oYData>
##
## Details:
##     Get the cursor position included (x,y)
## 
function Lfn_Cursor_Position()
{
    if [ $# -ne 2 -o -z "$1" -o -z "$2" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    echo -ne '\e[6n'; read -sdR LvCpPosition;
    #LvCpXPos=$(echo "${LvCpPosition#*[}" | cut -d ';' -f 1)
    #LvCpYPos=$(echo "${LvCpPosition#*[}" | cut -d ';' -f 2)

    LvCpXPos=$(echo "${LvCpPosition}" | awk -F ';'  '{print $2}')
    LvCpYPos=$(echo "${LvCpPosition}" | awk -F ';'  '{print $1}')

    eval $1="${LvCpXPos}"
    eval $2="${LvCpYPos}"
}



## Usage:
##     Lfn_Cursor_Mov <iOffset> <iDirection> 
## Details:
##     <iOffset>: it must be a digit
##     <iDirection>: up | down | left | right 
## Note:
##     iOffset=0 is the same to xNum=1
## Sample:
##     Lfn_Cursor_Mov 100 "up" 
##     sleep 5
##     Lfn_Cursor_Move 100  "right" 
## 
function Lfn_Cursor_Mov()
{
    if [ -z "$1" -o -z "$2" ]; then
        Lfn_Sys_FuncComment
        Lfn_Sys_DbgEcho "Sorry,Exit due to the invalid usage" 
        exit 0
    fi

    echo $1 | grep -E '[^0-9]' >/dev/null && LvCmFlag="0" || LvCmFlag="1";
    if [ x"${LvCmFlag}" = x"0" ]; then
        Lfn_Sys_DbgEcho "Sorry,Exit because the parameter1 isn't digit" 
        exit 0 
    fi

    if [ x"$2" != x"up" -a x"$2" != x"down" -a x"$2" != x"left" -a x"$2" != x"right" ]; then
        Lfn_Sys_DbgEcho "Sorry,Exit because the parameter2 isn't up|down|left|right"
        exit 0 
    fi  

    case $2 in
    up)
        #'\c' or '-n' - dont break line
        echo -ne "${CvAccOff}\033[$1A${CvAccOff}"
    ;;
    down)
        #'\c' or '-n' - dont break line
        echo -ne "${CvAccOff}\033[$1B${CvAccOff}"
    ;;
    right)
        #'\c' or '-n' - dont break line
        echo -ne "${CvAccOff}\033[$1C${CvAccOff}"
    ;;
    left)
        #'\c' or '-n' - dont break line
        echo -ne "${CvAccOff}\033[$1D${CvAccOff}"
    ;;
    *)
    ;;
    esac
}




## Usage:
##     Lfn_Cursor_Move <xNum>  <yNum> 
## Details:
##     xNum: Left/Right towards
##     yNum: Up/Down    towards
## Note:
##     xNum=0 is the same to xNum=1
##     yNum=0 is the same to yNum=1 
## Sample:
##     Lfn_Cursor_Move 100  4
##     sleep 5
##     Lfn_Cursor_Move 100  10 
## 
function Lfn_Cursor_Move()
{
    if [ -z "$1" -o -z "$2" ]; then
        Lfn_Sys_FuncComment
        Lfn_Sys_DbgEcho "Sorry,Exit due to the invalid usage" 
        exit 0
    fi

    echo $1 | grep -E '[^0-9]' >/dev/null && LvCmFlag="0" || LvCmFlag="1";
    if [ x"${LvCmFlag}" = x"0" ]; then
        Lfn_Sys_FuncComment
        Lfn_Sys_DbgEcho "Sorry,Return because the parameter1 isn't digit" 
        return; 
    fi

    echo $2 | grep -E '[^0-9]' >/dev/null && LvCmFlag="0" || LvCmFlag="1";
    if [ x"${LvCmFlag}" = x"0" ]; then
        Lfn_Sys_FuncComment
        Lfn_Sys_DbgEcho "Sorry,Return because the parameter2 isn't digit" 
        return; 
    fi

    #'\c' or '-n' - dont break line
    LvCmTargetLocation="${CvAccOff}\033[$2;$1H${CvAccOff}"
    echo -ne "${LvCmTargetLocation}"
}


function Lfn_Stdin_Flush()
{
    # clear all data continuely from stdin
    while read -s -t 1 -n 1; do
        continue
    done
}



## Usage:
##     Lfn_Stdin_Read <oKeyData>
## Note:
##     Shell cant recognize the space and enter keycode.
##     So the space and enter keycode will be ignored.
## Sample:
##     Lfn_Stdin_Read  oKeyData
##     echo "Get: $oKeyData"
function Lfn_Stdin_Read()
{
    if [ -z "$1" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to the bad usage"
        Lfn_Sys_FuncComment
        exit 0
    fi

    LvSrData=""

    # Read one byte from stdin
    trap : 2   # enable to capture the signal from keyboard input ctrl_c
    while read -s -n 1 LvSrData
    do
        case "${LvSrData}" in
        "")
            read -s -n 1 -t 1 LvSrData
            case "${LvSrData}" in
            "[")
                read -s -n 1 -t 1 LvSrData
                case "${LvSrData}" in
                "A")
                    LvSrData="KeyUp"
                ;;
                "B")
                    LvSrData="KeyDown"
                ;;
                "C") 
                    LvSrData="KeyRight"
                ;;
                "D")
                    LvSrData="KeyLeft"
                ;;
                *)
                    Lfn_Sys_DbgEcho "Dont Recognize KeyCode: ${LvSrData}"
                    continue;
                ;;
                esac 
            ;;
            "")
                LvSrData="KeyEsc"
            ;;
            *)
                Lfn_Sys_DbgEcho "Dont Recognize KeyCode: ${LvSrData}"
                continue;
            ;;
            esac
        ;;
        "")
            # Space Key and Enter Key arent recognized
            LvSrData="KeySpaceOrEnter"
            break;
        ;;
        *)
            break;
        ;;
        esac
        [ ! -z "${LvSrData}" ] && break;
    done
    trap "" 2  # disable to capture the singal from keyboard input ctrl_c
    eval $1="${LvSrData}"
}

## Lfn_Stdin_GetDigit <oResult> [<prompt>]
##
## Lfn_Stdin_GetDigit  oResult  "hello world: "
## echo "Result: $oResult"
function Lfn_Stdin_GetDigit()
{
    if [ ! -z "$2" ]; then
        LvSgdCmd='read -p "$2 " LvSgdNum'
    else
        LvSgdCmd='read LvSgdNum'
    fi

    LvSgdNum=""
    while [ -z "${LvSgdNum}" ]; do
        eval ${LvSgdCmd}   
        echo ${LvSgdNum} | grep -E '[^0-9]' >/dev/null && LvSgdNum="" || break; 
    done

    eval $1="${LvSgdNum}"
}


#######################################################
##       Path View v3 Design 
##     (Done By jielong.lin  @2015-12-02)
#######################################################
##
##   ===== hello title =====
##   │├── Root="/home/jielong.lin"
##   ││   ... [AbsolutePath="/home/jielong.lin"] [Depth=0]
##   ││   ├── jielong.lin
##   ││   │   ├── <<<PrevPage {Page:0/4}
##   ││   │   ├── [ ]eu.mainline +24
##   ││   │   ├── [ ]jll +1
##   ││   │   ├── [ ]JllLibrary +8
##   ││   │   ├── >>>NextPage {Page:2/4}
##
##   TRACE: [i=0,s=no] ==> [i=4,s=no]
##
###
### Usage:
### h: toParent
### l: toChildrent
### j: focus down
### k: focus up
### enter|space: enable/disable
###  

#--------------------------------
# PathView Component Definitions
#--------------------------------

declare -a  PVI_strNode
declare -a  PVI_i4Node         # 0:"unknown" 1:"button" 2:"checkbox"
declare -a  PVI_fnNodeAction   # Function Pointer to handle the input
declare -a  PVI_i4Relationship # The count of its subdirectory
declare -a  PVI_i4Raw
declare -a  PVI_i4Col
declare -i  PVI_i4NodeNr=0

PVL_strTitle=""
PVL_strRoot="/"                # please specify the absolute path
PVL_strNode="/"                # please specify the absolute path
PVL_i4Raw=3
PVL_i4Col=3
PVL_i4Depth=0                  # The distance level count from current path to root path
PVL_i4StringLength=50
PVL_i4Property=1               # Not support:if PVI_i4Node=2, then 0: Single Select, 1: Multilse Select
PVL_i4PageProbe=0              # Pointer To at where Collect data
PVL_i4PageUnit=2               # How many items are observed in every page
PVL_i4NodeNr=0                 # How many items are scanned in the current directory

PVL_i4ActivityNode=0           # Specify the Activity Tree Node

#----------------
# Debug Windows
#----------------
declare -i PVL_i4DbgRawBase
declare -i PVL_i4DbgColBase

function Fn_PathUtils_ClearLine()
{
    if [ $# -eq 1 ]; then
        echo "$1" | grep -E '[^0-9]' >/dev/null && LvPuclFlag=0 || LvPuclFlag=1;
        if [ x"${LvPuclFlag}" = x"1" ]; then
            Lfn_Cursor_Move "1" "$1"
            echo -ne "${CvAccOff}\033[K${CvAccOff}"
        fi
    fi
}

## Fn_PathUtils_ConvertToAbsolutePath <oResult> <iPath|iPathFile>
##
## Return the absolute path or pathfile.
## Note: Dont check the path if it exist 
##
## Fn_PathUtils_ConvertToAbsolutePath oResult "~/jielong/hello"
## echo "~/jielong/hello"
## echo "Result=\"${oResult}\""
## Fn_PathUtils_ConvertToAbsolutePath oResult "~/jielong/hello/"
## echo "~/jielong/hello/"
## echo "Result=\"${oResult}\""
## Fn_PathUtils_ConvertToAbsolutePath oResult "/jielong/hello"
## echo "/jielong/hello"
## echo "Result=\"${oResult}\""
## Fn_PathUtils_ConvertToAbsolutePath oResult "/jielong/hello/"
## echo "/jielong/hello/"
## echo "Result=\"${oResult}\""
## Fn_PathUtils_ConvertToAbsolutePath oResult "/"
## echo "/"
## echo "Result=\"${oResult}\""
## Fn_PathUtils_ConvertToAbsolutePath oResult "~/"
## echo "~/"
## echo "Result=\"${oResult}\""
## Fn_PathUtils_ConvertToAbsolutePath oResult "~"
## echo "~"
## echo "Result=\"${oResult}\""
## Fn_PathUtils_ConvertToAbsolutePath oResult "///"
## echo "///"
## echo "Result=\"${oResult}\""
##
## ~/jielong/hello
## Result="/home/jielong.lin/jielong/hello"
## ~/jielong/hello/
## Result="/home/jielong.lin/jielong/hello"
## /jielong/hello
## Result="/jielong/hello"
## /jielong/hello/
## Result="/jielong/hello"
## /
## Result="/"
## ~/
## Result="/home/jielong.lin"
## ~
## Result="/home/jielong.lin"
## ///
## Result="//"
function Fn_PathUtils_ConvertToAbsolutePath()
{
    if [ $# -ne 2 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_FuncComment
        exit 0
    fi

    LvPuctapTarget=$2

    # Check if the parameter <iPathFile>|<iPath> is valid, including convert "~/" to the absolute path
    LvPuctapFlag=$(echo ${LvPuctapTarget} | grep -E "^~")
    if [ ! -z "${LvPuctapFlag}" ]; then
        LvPuctapTarget=$(echo ${LvPuctapTarget} | sed "s/^~//g")
        LvPuctapTarget=$(echo ${LvPuctapTarget} | sed "s#^/##g")
        LvPuctapTarget="${HOME}/${LvPuctapTarget}"
    fi
    # Check if the config file path start with "/"
    LvPuctapFlag=$(echo "${LvPuctapTarget}" | grep -E "^/")
    if [ -z "${LvPuctapFlag}" ]; then
        LvPuctapTarget="$(pwd)/${LvPuctapTarget}"
    fi

    if [ x"${LvPuctapTarget}" != x"/" ]; then
        LvPuctapTarget="${LvPuctapTarget%%/}"
    fi
    eval $1="${LvPuctapTarget}"
}


## Not use
function Fn_PathSettings_DefaultSelector()
{
    echo "*** Default Settings Selector ***"
    echo "(1)Setting.5:"
    echo "     [Page.Unit] 5"
    echo "     [Cursor.Display] 1: enable"
    echo "     [Activity.Style] 1: Reverse Color"
    echo "(2)Setting.10:"
    echo "     [Page.Unit] 10"
    echo "     [Cursor.Display] 1: enable"
    echo "     [Activity.Style] 1: Reverse Color"
}


## Fn_PathUtils_HasSubdirectories <oResult>  <iPath>
##
## Return the number of the subdirectories to <oResult> from <iPath>
## if <oResult>=0, it represents it doestnt has any subdirectories.
##
## Example:
##     Fn_PathUtils_HasSubdirectories oResult "~"
##     echo "oResult: ${oResult}"
##
function Fn_PathUtils_HasSubdirectories()
{
    if [ $# -ne 2 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_FuncComment
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPuhsTargetPath "$2"
    # prevent the mistake due to the path contains some spaces from "awk -F ' ' '{print $9}'"
    # Hence use "awk -F ' ' '{print $1}'"
    LvPuhsList=$(ls -l ${LvPuhsTargetPath} | grep -E '^d' | awk -F ' ' '{print $1}')
    if [ x"${LvPuhsList}" != x ]; then
        LvPuhsCnt=0
        for LvPuhsEntry in ${LvPuhsList}; do
            LvPuhsCnt=$(( LvPuhsCnt + 1 )) 
        done
        eval $1=${LvPuhsCnt}
        unset LvPuhsEntry
        unset LvPuhsCnt
    else
        eval $1=0
    fi
    unset LvPuhsTargetPath
    unset LvPuhsList 
}


## Fn_PathUtils_HasParentdirectory <oResult>  <iPath>
##
## Return the number of the distance level from root directory to <oResult> from <iPath>
## if <oResult>=0, it represents it doestnt has a parent directory.
##
## Example:
##     Fn_PathUtils_HasParentdirectory oResult "~"
##     echo "oResult: ${oResult}"
##
function Fn_PathUtils_HasParentdirectory()
{
    if [ $# -ne 2 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_FuncComment
        exit 0
    fi

    if [ -z "${PVL_strRoot}" -o ! -e "${PVL_strRoot}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Please initialize the root path of PathViewList: PVL_strRoot"
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPuhpTargetPath "$2"
    if [ ! -e "${LvPuhpTargetPath}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because \"${LvPuhpTargetPath}\" dont exist"
        exit 0
    fi

    LvPuhpFlag=$(echo "${LvPuhpTargetPath}" | grep -E "${PVL_strRoot}")
    if [ x"${LvPuhpFlag}" = x ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because \"${LvPuhpTargetPath}\" dont rang in \"${PVL_strRoot}\""
        exit 0
    fi
    LvPuhpCount=0
    while [ x"${PVL_strRoot}" != x"${LvPuhpTargetPath}" ]; do
        LvPuhpTargetPath="$(cd ${LvPuhpTargetPath}/..;pwd)"
        LvPuhpCount=$(( LvPuhpCount + 1 ))
    done

    eval $1=${LvPuhpCount}
    unset LvPuhpTargetPath
    unset LvPuhpFlag
    unset LvPuhpCount
}




## Cleanup the Path View Nodes - PVI_strNode[PVL_i4PageUnit]
function Fn_PathData_Clean()
{
    # Contain two items: one prev page button and on nex page button
    if [ ${PVI_i4NodeNr} -gt 0 ]; then
        for (( LvPdcIndex=0 ; LvPdcIndex<PVI_i4NodeNr ; LvPdcIndex++ )) do
            unset PVI_strNode[LvPdcIndex]
            unset PVI_i4Node[LvPdcIndex]
            unset PVI_fnNodeAction[LvPdcIndex]
            unset PVI_i4Relationship[LvPdcIndex]
            unset PVI_i4Raw[LvPdcIndex]
            unset PVI_i4Col[LvPdcIndex]
        done
        unset LvPdcIndex
        PVI_i4NodeNr=0
    fi
}



## Fn_PathData_LoadPage <iPath>
##
## Load the subdirectories of <iPath> to Context list. 
## If exist previous page, PVI_strNode[0]="<<<PrevPage {Page:No/PageTotal}", or not
## If exist next page, PVI_strNode[PVI_i4Nr]=">>>NextPage {Page:No/PageTotal}", or not
##
## Example:
##     Fn_PathData_LoadPage "~" 
##
function Fn_PathData_LoadPage()
{
    if [ $# -ne 1 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit because of error parameter count"
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPdlpTargetPath  "$1"
    if [ ! -e "${LvPdlpTargetPath}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit because bad parameter 1 \"${LvPdlpTargetPath}\""
        exit 0
    fi

    # Scan the all diectory items from the specified path
    LvPdlpList=$(ls -l ${LvPdlpTargetPath} | grep -E '^d' | awk -F ' ' '{print $9}')
    if [ -z "${LvPdlpList}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because dont exist any valid items"
        unset LvPdlpTargetPath
        # None items exist.
        exit 0
    fi

    # If check the target path is a new path, should re-calculate the count of items 
    if [ x"${PVL_strNode}" != x"${LvPdlpTargetPath}" ]; then
        PVL_strNode="${LvPdlpTargetPath}"
        PVL_i4NodeNr=0
        for LvPdlpEntry in ${LvPdlpList}; do
            PVL_i4NodeNr=$(( PVL_i4NodeNr + 1 ))
        done
        PVL_i4PageProbe=0  # Relocate the page offset to 0

        # Calculate the Depth level from current path to root path 
        Fn_PathUtils_HasParentdirectory PVL_i4Depth "${LvPdlpTargetPath}"
        #echo "Current=\"${LvPdlpTargetPath}\""
        #echo "Root=\"${PVL_strRoot}\""
        #echo "Depth=${PVL_i4Depth}"
    fi

    Fn_PathData_Clean

    # Verify the PVL_i4PageProbe for align PVL_i4PageUnit.And PVL_i4PageProbe will be 
    # a multiple of PVL_i4PageUnit
    LvPdlpReservedValue="$(( PVL_i4PageProbe % PVL_i4PageUnit ))"
    if [ ${LvPdlpReservedValue} -ne 0 ]; then
        PVL_i4PageProbe="$[ PVL_i4PageProbe - LvPdslReservedValue ]"
    fi
    unset LvPdlpReservedValue

    #PVL_i4PageProbe=8
    #echo "PVL_i4PageProbe=${PVL_i4PageProbe}"
    LvPdlpIndex=0
    #
    # Calculate the previous page and next page
    # Load the page to Context List
    #
    LvPdlpSubdirectory=""
    if [ ${PVL_i4NodeNr} -le ${PVL_i4PageUnit} ]; then
        for LvPdlpEntry in ${LvPdlpList}; do
            PVI_strNode[LvPdlpIndex]="${LvPdlpEntry}"
            PVI_i4Node[LvPdlpIndex]=2 # Checkbox
            PVI_fnNodeAction[LvPdlpIndex]=Fn_PathView_Checkbox  # Fn_PathAction_Checkbox <iKeycode> <iComponentID> <iConfigFile>
            PVI_i4Raw[LvPdlpIndex]=${LvPdlpIndex}
            PVI_i4Col[LvPdlpIndex]=1
            LvPdlpSubdirectory="$(cd ${LvPdlpTargetPath}/${LvPdlpEntry};pwd)"
            Fn_PathUtils_HasSubdirectories PVI_i4Relationship[LvPdlpIndex] "${LvPdlpSubdirectory}"
            #echo "subdirs=[${PVI_strNode[LvPdlpIndex]}:${PVI_i4Relationship[LvPdlpIndex]}]"
            LvPdlpIndex=$[ LvPdlpIndex + 1 ]
        done
        unset LvPdlpEntry
        PVL_i4PageProbe=0
    else
        # Calculate the total pages
        LvPdlpValue="$(( PVL_i4NodeNr % PVL_i4PageUnit ))"
        if [ ${LvPdlpValue} -ne 0 ]; then
            LvPdlpValue="$[ PVL_i4NodeNr - LvPdlpValue + PVL_i4PageUnit ]"
            LvPdlpValue=$[ LvPdlpValue / PVL_i4PageUnit ]
        else
            LvPdlpValue=$[ PVL_i4NodeNr / PVL_i4PageUnit ]
        fi
 
        # Previous Page
        if [ ${PVL_i4PageProbe} -ge ${PVL_i4PageUnit} ]; then
            # Exist PrevPage
            PVI_strNode[LvPdlpIndex]="<<<PrevPage {Page:$(( PVL_i4PageProbe / PVL_i4PageUnit - 1 ))/${LvPdlpValue}}"
            PVI_i4Node[LvPdlpIndex]=1 # Button
            PVI_fnNodeAction[LvPdlpIndex]=Fn_PathView_PrevPageButton
            PVI_i4Raw[LvPdlpIndex]=${LvPdlpIndex}
            PVI_i4Col[LvPdlpIndex]=1
            PVI_i4Relationship[LvPdlpIndex]=0
            #echo "Prev:${PVI_strNode[LvPdlpIndex]}"
            LvPdlpIndex=$[ LvPdlpIndex + 1 ]
        fi

        # Current Context
        LvPdlpI=0
        for LvPdlpEntry in ${LvPdlpList}; do
            if [ ${LvPdlpI} -ge ${PVL_i4PageProbe} ]; then
                PVI_strNode[LvPdlpIndex]="${LvPdlpEntry}"
                PVI_i4Node[LvPdlpIndex]=2 # Checkbox
                PVI_fnNodeAction[LvPdlpIndex]=Fn_PathView_Checkbox
                PVI_i4Raw[LvPdlpIndex]=${LvPdlpIndex}
                PVI_i4Col[LvPdlpIndex]=1
                LvPdlpSubdirectory="$(cd ${LvPdlpTargetPath}/${LvPdlpEntry};pwd)"
                Fn_PathUtils_HasSubdirectories PVI_i4Relationship[LvPdlpIndex] "${LvPdlpSubdirectory}"
                #echo "subdirs=[${PVI_strNode[LvPdlpIndex]}:${PVI_i4Relationship[LvPdlpIndex]}]"
                LvPdlpIndex=$[ LvPdlpIndex + 1 ]
                if [ $(( LvPdlpI + 1 - PVL_i4PageProbe )) -ge ${PVL_i4PageUnit} ]; then
                    #echo "Over: $LvPdlpI  Index:$LvPdlpIndex"
                    break;
                fi
            fi
            LvPdlpI=$[ LvPdlpI + 1 ]
        done
        unset LvPdlpEntry

        # Next Page
        LvPdlpI=$(( PVL_i4NodeNr - PVL_i4PageUnit ))
        if [ ${PVL_i4PageProbe} -lt ${LvPdlpI} ]; then
            # Exist NextPage
            PVI_strNode[LvPdlpIndex]=">>>NextPage {Page:$(( PVL_i4PageProbe / PVL_i4PageUnit + 1 ))/${LvPdlpValue}}"
            PVI_i4Node[LvPdlpIndex]=1 # Button
            PVI_fnNodeAction[LvPdlpIndex]=Fn_PathView_NextPageButton
            PVI_i4Raw[LvPdlpIndex]=${LvPdlpIndex}
            PVI_i4Col[LvPdlpIndex]=1
            PVI_i4Relationship[LvPdlpIndex]=0
            #echo "Next:${PVI_strNode[LvPdlpIndex]}"
            LvPdlpIndex=$[ LvPdlpIndex + 1 ]
        fi
        unset LvPdlpI
    fi
    PVI_i4NodeNr=${#PVI_strNode[@]}
    PVL_i4ActivityNode=0
    unset LvPdlpSubdirectory
    unset LvPdlpIndex
    unset LvPdlpList
    unset LvPdlpValue
}



## Fn_PathData_CheckIfIsSelected <iConfigFile> <iNode> <oIsSelectedOrNot>
##
##     When enter into the directory, check the configurate file if its all parents directories 
##     status started with the current directory. If its some parent is selected, then all items
##     will be marked to the selected status.
##
## <iNode>  check the PVL_strNode if iNode=99999 
## 
## <oIsSelectedOrNot>
##    no: Not Select
##    yes: Select
function Fn_PathData_CheckIfIsSelected()
{
    if [ $# -ne 3 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_FuncComment
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPdcisConfigFile "$1"
    if [ x"${LvPdcisConfigFile}" = x ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of ConfigFile=\"${LvPdcisConfigFile}\" is invalid"
        exit 0
    fi

    if [ x"${PVL_strNode}" = x -o ! -e "${PVL_strNode}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, PVL_strNode=\"${PVL_strNode}\" isnt a valid"
        unset LvPdcisConfigFile
        exit 0
    fi

    if [ x"${PVL_strRoot}" = x -o ! -e "${PVL_strRoot}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, PVL_strRoot=\"${PVL_strRoot}\" isnt a valid"
        unset LvPdcisConfigFile
        exit 0
    fi

    # Check if parameter as ID is digit and is valid parameter 
    echo "$2" | grep -E '[^0-9]' >/dev/null && unset LvPdcisMax || LvPdcisMax=${#PVI_strNode[@]};
    if [ -z "${LvPdcisMax}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of parameter 2 isnt a digit"
        Lfn_Sys_FuncComment
        unset LvPdcisConfigFile
        exit 0
    fi
    if [ $2 -gt ${LvPdcisMax} -o $2 -eq ${LvPdcisMax} ]; then
        if [ $2 -ne 99999 ]; then
            Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
            Lfn_Sys_DbgEcho "Sorry, Exit Because of parameter 2 \"$2\" isnt in the range of \"${LvPdcisMax}\""
            Lfn_Sys_FuncComment
            unset LvPdcisConfigFile
            unset LvPdcisMax
            exit 0
        else
            LvPdcisItem="${PVL_strNode}"  # check all
        fi
    else
        LvPdcisItem="${PVL_strNode}/${PVI_strNode[$2]}"
    fi
    LvPdcisParentItem="${LvPdcisItem}"
    LvPdcisSelect="no"
    while [ 1 ]; do
        Lfn_File_GetFirstFullMatchLine LvPdcisFlag "${LvPdcisParentItem}" "${LvPdcisConfigFile}"
        if [ ! -z "${LvPdcisFlag}" ]; then # exist that it represents the parent path is selected.
            LvPdcisSelect="yes"
            break
        fi
        if [ x"${LvPdcisParentItem}" != x"${PVL_strRoot}" ]; then
            # try to check if its parent is selected.
            LvPdcisParentItem="${LvPdcisParentItem%/*}"
        else
            break
        fi
    done

    eval $3="${LvPdcisSelect}"
}


## Fn_PathUtils_Checkbox  <iKeycode> <iConfigFile>
function Fn_PathView_Checkbox()
{
    if [ x"$1" = x"KeySpaceOrEnter" ]; then
        # Trigger Path View Choice to the configurate file
        Fn_PathView_ReverseToSettings "${PVL_i4ActivityNode}" "$2" LvPucFlag
        if [ x"${LvPucFlag}" = x"0" ]; then  # Cancel the choice
            Fn_PathView_Render_TreeNode "${PVL_i4ActivityNode}" "Reverse" "no"
        else # Select the choice
            Fn_PathView_Render_TreeNode "${PVL_i4ActivityNode}" "Reverse" "yes"
        fi
    fi
}

## Fn_PathView_PrevPageButton <iKeycode> <iConfigFile>
function Fn_PathView_PrevPageButton()
{
    if [ x"$1" = x"KeySpaceOrEnter" ]; then
        # Verify the PVL_i4PageProbe
        LvPuppbReservedValue=$(( PVL_i4PageProbe % PVL_i4PageUnit ))
        PVL_i4PageProbe=$(( PVL_i4PageProbe - LvPuppbReservedValue ))
        if [ ${PVL_i4NodeNr} -gt ${PVL_i4PageUnit} ]; then
            if [ ${PVL_i4PageProbe} -ge ${PVL_i4PageUnit} ]; then
                PVL_i4PageProbe=$(( PVL_i4PageProbe - PVL_i4PageUnit ))
                # Reload the previous page data 
                Fn_PathData_LoadPage "${PVL_strNode}"
                # Render the page view
                Fn_PathView_RenderDriver "$2"
            fi
        fi 
    fi
}

## Fn_PathView_NextPageButton <iKeycode> <iConfigFile>
function Fn_PathView_NextPageButton()
{
    if [ x"$1" = x"KeySpaceOrEnter" ]; then
        # Verify the PVL_i4PageProbe
        LvPuppbReservedValue=$(( PVL_i4PageProbe % PVL_i4PageUnit ))
        PVL_i4PageProbe=$(( PVL_i4PageProbe - LvPuppbReservedValue ))
        if [ ${PVL_i4NodeNr} -gt ${PVL_i4PageUnit} ]; then
            LvPuppbReservedValue=$(( PVL_i4NodeNr % PVL_i4PageUnit ))
            LvPuppbReservedValue=$(( PVL_i4NodeNr - LvPuppbReservedValue ))
Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
echo "${PVL_i4PageProbe} -lt ${LvPuppbReservedValue}"
            if [ ${PVL_i4PageProbe} -lt ${LvPuppbReservedValue} ]; then
                PVL_i4PageProbe=$(( PVL_i4PageProbe + PVL_i4PageUnit ))
                # Reload the previous page data 
                Fn_PathData_LoadPage "${PVL_strNode}"
                # Render the page view
                Fn_PathView_RenderDriver "$2"
            fi 
        fi
    fi
}


##
##   ===== ${PVL_strTitle} =====
##   │├── Root="${PVL_strRoot}"
##   ││   ... [AbsolutePath="${PVL_strNode}"] [Depth=${PVL_i4Depth}]
##
function Fn_PathView_Render_TreeHead()
{
    LvPvrthHeadLength=$(( PVL_i4StringLength + 20 ))

    LvPvrthTitle="${PVL_strTitle}"
    # Cut off the specified LvPvrthHeadLength characters
    LvPvrthTitle="$(echo ${LvPvrthTitle:0:${LvPvrthHeadLength}})"$([ x"${LvPvrthTitle:${LvPvrthHeadLength}}" != x ] && echo ...)

    LvPvrthRoot="${PVL_strRoot}"
    # Cut off the specified LvPvrthHeadLength characters
    LvPvrthRoot="$(echo ${LvPvrthRoot:0:${LvPvrthHeadLength}})"$([ x"${LvPvrthRoot:${LvPvrthHeadLength}}" != x ] && echo ...)

    LvPvrthNode="${PVL_strNode}"
    # Cut off the specified LvPvrthHeadLength characters
    LvPvrthNode="$(echo ${LvPvrthNode:0:${LvPvrthHeadLength}})"$([ x"${LvPvrthNode:${LvPvrthHeadLength}}" != x ] && echo ...)

    # Render the item
    Lfn_Cursor_Move ${PVL_i4Col} ${PVL_i4Raw}
    echo -ne "===== ${LvPvrthTitle} ====="
    Lfn_Cursor_Move ${PVL_i4Col} $(( ${PVL_i4Raw} + 1 ))
    echo -ne "│├── Root=\"${LvPvrthRoot}\""
    Lfn_Cursor_Move ${PVL_i4Col} $(( ${PVL_i4Raw} + 2 ))
    echo -ne "││   ... [AbsolutePath=\"${LvPvrthNode}\"] [Depth=${PVL_i4Depth}]"
    Lfn_Cursor_Move ${PVL_i4Col} $(( ${PVL_i4Raw} + 3 ))
    echo -ne "││   ├── $( basename ${PVL_strNode} )"
    # The cursor is moved to the Top.
    Lfn_Cursor_Move 1 1 
}


## Fn_PathView_Render_TreeNode <iNodeIndex> <iDisplayStyle> [<iYourChoiceIsYesOrNo>]
##
## <iNodeIndex> is ranged from 0 to index in PVI_strNode[...]
## <iDisplayStyle> is the one of the follows
##     "Normal" - Normal display style
##     "Reverse" - Reverse display style
## <iYourChoiceIsYesOrNo> is either yes or no for checkbox
##
## Render one item As follows:
##
##   ││   │   ├── <<<PrevPage {Page:0/4}
##   ││   │   ├── [ ]eu.mainline +24
##   ││   │   ├── [ ]jll +1
##   ││   │   ├── [ ]JllLibrary +8
##   ││   │   ├── >>>NextPage {Page:2/4}
##
## Note: Page:0/4 , 0=PageNo. 4=PageTotal
## Note: [ ]jll +1 , +1="jll" has one subdirectory
##
function Fn_PathView_Render_TreeNode()
{
    if [ $# -lt 2 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of error parameter count"
        exit 0
    fi

    # Check if parameter as ID is digit and is valid parameter 
    echo "$1" | grep -E '[^0-9]' >/dev/null && unset LvPvrwtsMax || LvPvrwtsMax=${#PVI_strNode[@]};
    if [ -z "${LvPvrwtsMax}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of parameter 1 isnt a digit"
        Lfn_Sys_FuncComment
        exit 0
    fi
    if [ $1 -gt ${LvPvrwtsMax} -o $1 -eq ${LvPvrwtsMax} ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of parameter 1 \"$1\" isnt in the range of \"${LvPvrwtsMax}\""
        Lfn_Sys_FuncComment
        unset LvPvrwtsMax
        exit 0
    fi

    LvPvrwtsNodeId=$1

    # Handle to render view by the type of component with PVI_i4Node[LvPvrwtsNodeId]
    LvPvrwtsItem=""
    case ${PVI_i4Node[LvPvrwtsNodeId]} in 
    1) # Button
        LvPvrwtsItem="${PVI_strNode[LvPvrwtsNodeId]}"
        # Cut off the specified PVL_i4StringLength characters 
        LvPvrwtsItem="$(echo ${LvPvrwtsItem:0:${PVL_i4StringLength}})"$([ x"${LvPvrwtsItem:${PVL_i4StringLength}}" != x ] && echo ...)
        ;;
    2) # Checkbox 
        # Check if parameter 3 is a valid parameter 
        if [ x"$3" != x"yes" -a x"$3" != x"no" ]; then
            Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
            Lfn_Sys_DbgEcho "Sorry, Exit Because of parameter 3 \"$3\" isnt a valid"
            Lfn_Sys_FuncComment
            unset LvPvrwtsItem
            unset LvPvrwtsNodeId
            unset LvPvrwtsMax
            exit 0
        fi
        LvPvrwtsItem="${PVI_strNode[LvPvrwtsNodeId]}"
        if [ x"$3" = x"yes" ]; then
            LvPvrwtsItem="[*]${LvPvrwtsItem}"
        else
            LvPvrwtsItem="[ ]${LvPvrwtsItem}"
        fi

        # Cut off the specified PVL_i4StringLength characters 
        LvPvrwtsItem="$(echo ${LvPvrwtsItem:0:${PVL_i4StringLength}})"$([ x"${LvPvrwtsItem:${PVL_i4StringLength}}" != x ] && echo ...)

        if [ ${PVI_i4Relationship[LvPvrwtsNodeId]} -gt 0 ]; then
            LvPvrwtsItem="${LvPvrwtsItem} +${PVI_i4Relationship[LvPvrwtsNodeId]}"
        fi
        ;;
    *) # Unknown
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit because Cant rendering the component because unknown its type"
        unset LvPvrwtsItem
        unset LvPvrwtsNodeId
        unset LvPvrwtsMax
        exit 0
        ;;
    esac

    # Render the item
    Fn_PathUtils_ClearLine "$(( ${PVL_i4Raw} + ${PVI_i4Raw[LvPvrwtsNodeId]} + 4 ))" 
    Lfn_Cursor_Move ${PVL_i4Col} $(( ${PVL_i4Raw} + ${PVI_i4Raw[LvPvrwtsNodeId]} + 4 ))
    case $2 in
    Reverse)
        echo -ne "││   │   ├── ${CvAccOff}\033[07m${LvPvrwtsItem}"
        ;;
    Normal)
        echo -ne "││   │   ├── ${LvPvrwtsItem}"
        ;;
    *)
        echo -ne "Sorry, Dont specify the valid Display Style Parameter"
        ;;
    esac
    # The cursor is moved to Debug Windows.
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "${PVL_i4DbgRawBase}" 
}

## Fn_PathView_Render_TreeNode_Activity <iNodeIndex> <iDisplayStyle> <iConfigFile>
##
## Cancel the style of the previous focus tree node to Normal style.
## Then Activity the <iDisplayStyle> styple of the <iNodeIndex> tree node.
## 
function Fn_PathView_Render_TreeNode_Activity()
{
    if [ $# -ne 3 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of the error parameter count"
        Lfn_Sys_FuncComment
        exit 0
    fi

    # Check if parameter as ID is digit and is valid parameter 
    echo "$1" | grep -E '[^0-9]' >/dev/null && unset LvPvrtnaMax || LvPvrtnaMax=${#PVI_strNode[@]};
    if [ -z "${LvPvrtnaMax}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of parameter 1 isnt a digit"
        Lfn_Sys_FuncComment
        exit 0
    fi
    if [ $1 -gt ${LvPvrtnaMax} -o $1 -eq ${LvPvrtnaMax} ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of parameter 1 \"$1\" isnt in the range of \"${LvPvrtnaMax}\""
        Lfn_Sys_FuncComment
        unset LvPvrtnaMax
        exit 0
    fi

    # Convert the $3 to the absolute path
    Fn_PathUtils_ConvertToAbsolutePath LvPvrtnaConfigFile "$3"
    if [ x"${LvPvrtnaConfigFile}" = x ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of ConfigFile=\"${LvPvrtnaConfigFile}\" is invalid"
        unset LvPvrtnaMax
        exit 0
    fi

    # Query the selected status from item specified by PVL_i4ActivityNode up to root directories.
    Fn_PathData_CheckIfIsSelected "$3" "${PVL_i4ActivityNode}" LvPvrtnaSelect0
    # Cancel the style of the previous Item 
    Fn_PathView_Render_TreeNode "${PVL_i4ActivityNode}" "Normal" "${LvPvrtnaSelect0}" 

    # Query the selected status from item specified by $1 up to root directories.
    Fn_PathData_CheckIfIsSelected "$3" "$1" LvPvrtnaSelect1
    # Cancel the style of the previous Item 
    Fn_PathView_Render_TreeNode "$1" "$2" "${LvPvrtnaSelect1}" 
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 1 ))" 
    Lfn_Sys_ColorEcho ${CvBgRed}  ${CvFgWhite} "TRACE: [i=${PVL_i4ActivityNode},s=${LvPvrtnaSelect0}] ==> [i=$1,s=${LvPvrtnaSelect1}]"
    #echo "TRACE: [i=${PVL_i4ActivityNode},s=${LvPvrtnaSelect0}] ==> [i=$1,s=${LvPvrtnaSelect1}]"

    unset LvPvrtnaSelect0
    unset LvPvrtnaSelect1
}


## Fn_PathView_ReverseToSettings <iNode> <iFile> <oValue>
##
## <oValue> = 1 : represent selected
## <oValue> = 0 : represent unselected 
##
function Fn_PathView_ReverseToSettings()
{
    if [ $# -ne 3 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of error parameter count"
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPvrtsConfigFile "$2"

    # Check if exist the config file
    if [ ! -e "${LvPvrtsConfigFile}" ]; then
        # Create the new config file
        touch ${LvPvrtsConfigFile}
        chmod 0777 ${LvPvrtsConfigFile}
        if [ ! -e "${LvPvrtsConfigFile}" ]; then
            Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
            Lfn_Sys_DbgEcho "Sorry, Exit because cant create the config file: \"${LvPvrtsConfigFile}\""
            exit 0
        fi
    fi
 
    # Check if parameter <iContextId> as context ID is digit and is valid
    echo "$1" | grep -E '[^0-9]' >/dev/null && unset LvPvrtsMax || LvPvrtsMax=${#PVI_strNode[@]};
    if [ -z "${LvPvrtsMax}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because parameter 1 isnt a digit"
        Lfn_Sys_FuncComment
        unset LvPvrtsConfigFile
        exit 0
    fi
    if [ $1 -gt ${LvPvrtsMax} -o $1 -eq ${LvPvrtsMax} ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because the parameter 1 isnt a valid"
        Lfn_Sys_FuncComment
        unset LvPvrtsConfigFile
        unset LvPvrtsMax
        exit 0
    fi
    if [ -z ${LvPvrtsMax} -o ${LvPvrtsMax} -lt 1 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because none items is in Path View Context, suggest to run \"Fn_PathView_ScanToConfigFile\""
        Lfn_Sys_FuncComment
        unset LvPvrtsConfigFile
        unset LvPvrtsMax
        exit 0
    fi

    # Get the path of the specified item in path tree
    LvPvrtsItem="${PVL_strNode}/${PVI_strNode[$1]}"

    # Get the item status if it is selected. 
    # Maybe it isnt exist config file when Ui shows its selected status.
    # So its status is queried from the current item upto the root node in tree. 
    LvPvrtsSelect="no"
    LvPvrtsParentItem="$(cd ${LvPvrtsItem};pwd)"
    while [ 1 ]; do
        Lfn_File_GetFirstFullMatchLine LvPvrtsFlag "${LvPvrtsParentItem}" "${LvPvrtsConfigFile}"
        if [ ! -z "${LvPvrtsFlag}" ]; then # exist that it represents the parent path is selected.
            LvPvrtsRootNode="${LvPvrtsParentItem}" # The deleting item node
            LvPvrtsSelect="yes"
            break
        fi
        if [ x"${LvPvrtsParentItem}" != x"${PVL_strRoot}" ]; then
            # try to check if its parent is selected.
            # LvPvrtsParentItem="${LvPvrtsParentItem%/*}"
            LvPvrtsParentItem="$(cd ${LvPvrtsParentItem}/..;pwd)"
        else
            break
        fi
    done

    if [ x"${LvPvrtsSelect}" = x"yes" ]; then # status is selected because selected node is found
        if [ x"${LvPvrtsItem}" = x"${LvPvrtsParentItem}" ]; then # self is stored in config file
            Lfn_File_DeletePreciseMatchLine  "${LvPvrtsParentItem}"  "${LvPvrtsConfigFile}"
        else
            LvPvrtsItem_="${LvPvrtsItem}"
            LvPvrtsParentItem="$(cd ${LvPvrtsItem_}/..;pwd)" # handle from its parent directory
            echo > ${LvPvrtsConfigFile}.temp
            while [ 1 ]; do
                if [ x"${LvPvrtsParentItem}" = x"${LvPvrtsRootNode}" ]; then # delete division line
                    Lfn_File_DeletePreciseMatchLine  "${LvPvrtsParentItem}"  "${LvPvrtsConfigFile}"
                fi

                LvPvrtsSubdirs=$(ls -l ${LvPvrtsParentItem} | grep -E '^d' | awk -F ' ' '{print $9}')
                if [ ! -z "${LvPvrtsSubdirs}" ]; then
                    for LvPvrtsSubEntry in ${LvPvrtsSubdirs}; do
                        LvPvrtsSubEntry="$(cd ${LvPvrtsParentItem}/${LvPvrtsSubEntry};pwd)"
                        if [ x"${LvPvrtsSubEntry}" = x"${LvPvrtsItem_}" ]; then
                            continue
                        fi
                        echo "${LvPvrtsSubEntry}" >> ${LvPvrtsConfigFile}.temp
                    done
                fi
                if [ x"${LvPvrtsParentItem}" != x"${LvPvrtsRootNode}" ]; then
                    LvPvrtsItem_="${LvPvrtsParentItem}"
                    LvPvrtsParentItem="$(cd ${LvPvrtsItem_}/..;pwd)"
                else
                    break
                fi
            done
        fi
        if [ -e "${LvPvrtsConfigFile}.temp" ]; then
            cat ${LvPvrtsConfigFile}.temp >> ${LvPvrtsConfigFile}
            rm -rf ${LvPvrtsConfigFile}.temp
        fi
        eval $3="0"
    else # status is unselected because dont find the selected node.
    # run here to represent the parent directory isnt stored in config file
    # but should check all brother directories when selected.And then upto
    # check as the same method.

        # Remove its all subdirectories from config and then append itself to config
        LvPvrtsSubdirs=$(ls -l ${LvPvrtsItem} | grep -E '^d' | awk -F ' ' '{print $9}')
        if [ ! -z "${LvPvrtsSubdirs}" ]; then
            for LvPvrtsSubEntry in ${LvPvrtsSubdirs}; do
                LvPvrtsSubEntry="$(cd ${LvPvrtsItem}/${LvPvrtsSubEntry};pwd)"
                Lfn_File_DeletePreciseMatchLine  "${LvPvrtsSubEntry}"  "${LvPvrtsConfigFile}"
            done
        fi
        echo "${LvPvrtsItem}" >> ${LvPvrtsConfigFile}
 
        LvPvrtsItem_="${LvPvrtsItem}"
        LvPvrtsParentItem="$(cd ${LvPvrtsItem_}/..;pwd)"
        while [ 1 ]; do
            LvPvrtsNeedToMergeAndSelected=1
            LvPvrtsSubdirs=$(ls -l ${LvPvrtsParentItem} | grep -E '^d' | awk -F ' ' '{print $9}')
            if [ ! -z "${LvPvrtsSubdirs}" ]; then
                for LvPvrtsSubEntry in ${LvPvrtsSubdirs}; do
                    LvPvrtsSubEntry="$(cd ${LvPvrtsParentItem}/${LvPvrtsSubEntry};pwd)"
                    Lfn_File_GetFirstFullMatchLine LvPvrtsFlag "${LvPvrtsSubEntry}" "${LvPvrtsConfigFile}"
                    if [ -z "${LvPvrtsFlag}" ]; then # not exist config, and it is unselect
                        LvPvrtsNeedToMergeAndSelected=0
                        break
                    fi
                #    Lfn_File_DeletePreciseMatchLine  "${LvPvrtsSubEntry}"  "${LvPvrtsConfigFile}"
                done
            fi
            if [ ${LvPvrtsNeedToMergeAndSelected} -eq 1 ]; then
                if [ ! -z "${LvPvrtsSubdirs}" ]; then
                    for LvPvrtsSubEntry in ${LvPvrtsSubdirs}; do
                        LvPvrtsSubEntry="$(cd ${LvPvrtsParentItem}/${LvPvrtsSubEntry};pwd)"
                        Lfn_File_DeletePreciseMatchLine  "${LvPvrtsSubEntry}"  "${LvPvrtsConfigFile}"
                    done
                fi
                echo "${LvPvrtsParentItem}" >> ${LvPvrtsConfigFile}
                LvPvrtsItem_="${LvPvrtsParentItem}"
                LvPvrtsParentItem="$(cd ${LvPvrtsItem_}/..;pwd)"
            else
                break
            fi
        done

        eval $3="1"
    fi

    return
}


function Fn_PathView_Help()
{
    LvPvhRaw="$(( PVL_i4DbgRawBase + 6 ))"
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 0 ))"
    echo "******************* Help For Usage **********************"
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 1 ))"
    echo "  Note: Page:0/4 , 0=PageNo. 4=PageTotal"
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 2 ))"
    echo "  Note: ├── [ ]jll +2 , +2="jll" has two subdirectories"
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 3 ))"
    echo " -------------------------------------------------------"
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 4 ))"
    echo "  h|left:      toParent "
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 5 ))"
    echo "  l|right:     toChildrent "
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 6 ))"
    echo "  j|down:      focus down "
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 7 ))"
    echo "  k|up:        focus up "
    Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( LvPvhRaw + 8 ))"
    echo "  enter|space: enable/disable "
    unset LvPvhRaw
}


## Fn_PathView_RenderDriver <iFile>
##
## Renderring the Path View with Tree Topology
##
## Note: Dont modify any config.
function Fn_PathView_RenderDriver()
{
    if [ $# -ne 1 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of error parameter count"
        Lfn_Sys_FuncComment
        exit 0
    fi

    if [ x"${PVL_strNode}" = x -o ! -e "${PVL_strNode}" ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of PVL_strNode=\"${PVL_strNode}\" is invalid"
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPvrdConfigFile "$1"
    if [ x"${LvPvrdConfigFile}" = x ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of ConfigFile=\"${LvPvrdConfigFile}\" is invalid"
        exit 0
    fi

    # When enter into the directory, check the configurate file if its all parents directories 
    # status started with the current directory. If its some parent is selected, then all items
    # will be marked to the selected status. 
    LvPvrdSelect="no"
    Fn_PathData_CheckIfIsSelected "${LvPvrdConfigFile}" 99999  LvPvrdSelect

    clear
    Fn_PathView_Render_TreeHead

    for (( LvPvrdId=0 ; LvPvrdId<${PVI_i4NodeNr} ; LvPvrdId++ )) do
        if [ ${LvPvrdId} -eq ${PVL_i4ActivityNode} ]; then
            LvPvrdStyle="Reverse"
        else
            LvPvrdStyle="Normal"
        fi

        if [ ${PVI_i4Node[LvPvrdId]} -eq 1 ]; then # button component dont need parameter 3
            Fn_PathView_Render_TreeNode "${LvPvrdId}" "${LvPvrdStyle}"
            continue
        fi
        # Render every Menu Item with selected status if parent path is selected
        if [ x"${LvPvrdSelect}" = x"yes" ]; then
            Fn_PathView_Render_TreeNode "${LvPvrdId}" "${LvPvrdStyle}" "yes"
            continue
        fi
        # Get the path of the specified item
        LvPvrdItem="${PVL_strNode}/${PVI_strNode[LvPvrdId]}"
        # Render every item according to the configurate file if parent path is unselected
        Lfn_File_GetFirstFullMatchLine LvPvrdFlag "${LvPvrdItem}" "${LvPvrdConfigFile}"
        if [ ! -z "${LvPvrdFlag}" ]; then # exist
            Fn_PathView_Render_TreeNode "${LvPvrdId}" "${LvPvrdStyle}" "yes"
        else
            Fn_PathView_Render_TreeNode "${LvPvrdId}" "${LvPvrdStyle}" "no"
        fi
    done

    # Display the Help Windows
    Fn_PathView_Help 
}


## Fn_PathView_UiMain <iRootPath> <iFile> <iTitle>
##
## Result: Generate a configurate file "<iFile>"
##
function Fn_PathView_UiMain()
{
    # Ctrl_c : 3=SIGINT
    # Ctrl_z : 20=SIGTSTP
    # trap "clear;exit 0" 3 20 

    if [ $# -ne 3 ]; then
        Lfn_Cursor_Move "${PVL_i4DbgColBase}" "$(( PVL_i4DbgRawBase + 3 ))" 
        Lfn_Sys_DbgEcho "Sorry, Exit Because of error parameter count"
        exit 0
    fi

    # re-build the configurate
    Fn_PathUtils_ConvertToAbsolutePath LvPvumConfigFile "$2"
    if [ -e "${LvPvumConfigFile}" ]; then
        #echo "NOTICE: Do you clear ${LvPvumConfigFile}"
        echo > ${LvPvumConfigFile}
    else
        touch ${LvPvumConfigFile}
        chmod 0777 ${LvPvumConfigFile}
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPvumCurrentPath "$1"

    Lfn_Cursor_EchoConfig "off"

    # PVL_strRoot
    # PVL_strNode,PVL_i4NodeNr,PVL_i4Depth,PVL_i4PageProbe will be set by Fn_PathData_LoadPage
    # PVL_strTitle
    # PVL_i4Raw,PVL_i4Col,PVL_i4StringLength,PVL_i4Property,PVL_i4PageUnit
    PVL_strRoot="$(cd ${LvPvumCurrentPath};pwd)"
    PVL_strTitle="$3"
    PVL_i4Raw=4
    PVL_i4Col=4
    PVL_i4StringLength=30
    PVL_i4Property=1
    PVL_i4PageUnit=7

    PVL_i4DbgRawBase=$(( PVL_i4Raw + PVL_i4PageUnit + 6 )) 
    PVL_i4DbgColBase=${PVL_i4Col}

    Fn_PathData_LoadPage "${PVL_strRoot}"

    Fn_PathView_RenderDriver "${LvPvumConfigFile}"

    # Input Handle and Realtime Render
    while [ 1 ]; do
        # Read one byte from stdin
        Lfn_Stdin_Read LvCustuiData

        case "${LvCustuiData}" in
        "KeyUp"|"k")
            LvPvumFocusNodeIdx=${PVL_i4ActivityNode}
            if [ ${LvPvumFocusNodeIdx} -le 0 ]; then
                LvPvumFocusNodeIdx=$(( PVI_i4NodeNr - 1 ))
            else
                LvPvumFocusNodeIdx=$(( LvPvumFocusNodeIdx - 1 ))
            fi
            Fn_PathView_Render_TreeNode_Activity "${LvPvumFocusNodeIdx}" "Reverse" "${LvPvumConfigFile}"
            PVL_i4ActivityNode=${LvPvumFocusNodeIdx}
            unset LvPvumFocusNodeIdx 
        ;;
        "KeyDown"|"j")
            LvPvumFocusNodeIdx=${PVL_i4ActivityNode}
            LvPvumFocusNodeIdx=$[ LvPvumFocusNodeIdx + 1 ]
            if [ ${LvPvumFocusNodeIdx} -ge ${PVI_i4NodeNr} ]; then
                LvPvumFocusNodeIdx=0
            fi
            Fn_PathView_Render_TreeNode_Activity "${LvPvumFocusNodeIdx}" "Reverse" "${LvPvumConfigFile}"
            PVL_i4ActivityNode=${LvPvumFocusNodeIdx}
            unset LvPvumFocusNodeIdx 
        ;;
        "KeyLeft"|"h") # up to parent direction 
            if [ ${PVL_i4Depth} -gt 0 ]; then
                LvPvumCurrentPath="$(cd ${PVL_strNode}/../;pwd)"
                Fn_PathData_LoadPage "${LvPvumCurrentPath}"
                Fn_PathView_RenderDriver "${LvPvumConfigFile}"
            fi
        ;;
        "KeyRight"|"l") # down to child direction
            if [ ${PVI_i4Relationship[PVL_i4ActivityNode]} -gt 0 ]; then
                LvPvumCurrentPath="$(cd ${PVL_strNode}/${PVI_strNode[PVL_i4ActivityNode]};pwd)"
                Fn_PathData_LoadPage "${LvPvumCurrentPath}"
                Fn_PathView_RenderDriver "${LvPvumConfigFile}"
            fi
        ;;
        "q")
            clear
            break;
        ;;
        "KeySpaceOrEnter") # select or unselect the choice
            eval ${PVI_fnNodeAction[PVL_i4ActivityNode]} "KeySpaceOrEnter" "$2" 
        ;;
        *)
        ;;
        esac
    done 
    Lfn_Cursor_EchoConfig "on"
}

## Fn_PathView_UiMain  "~/" "pathview.config" "hello title"
## exit 0


## Fn_PathUtils_GetRootPathFromConfigFile <oResult> <iConfigFilePath>
##
## Fn_PathUtils_GetRootPathFromConfigFile oResult "~/pathview.config"
## echo "${oResult}"
function Fn_PathUtils_GetRootPathFromConfigFile()
{
    if [ $# -ne 2 ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPugrpfcfPath "$2" 
    if [ -z "${LvPugrpfcfPath}" -o ! -e "${LvPugrpfcfPath}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because of the invalid path\"${LvPugrpfcfPath}\""
        exit 0
    fi

    #read first non-null file line and check if it is path file
    LvPugrpfcfRootPath=""
    LvPugrpfcfIdx=0
    declare -a LvPugrpfcfFile;
    while read LvPugrpfcfLine; do
        if [ -z "${LvPugrpfcfLine}" ]; then
            continue
        fi
        # Check if it is path
        if [ ! -e "${LvPugrpfcfLine}" -o ! -d "${LvPugrpfcfLine}" ]; then
            Lfn_Sys_DbgEcho "Sorry, Return because the config file contains an invalid path:"
            Lfn_Sys_DbgEcho " \"${LvPugrpfcfLine}\""
            eval $1=""
            unset LvPugrpfcfFile
            return 
        fi
        LvPugrpfcfFile[LvPugrpfcfIdx]="${LvPugrpfcfLine}"
        LvPugrpfcfIdx=$(expr ${LvPugrpfcfIdx} + 1)
    done < ${LvPugrpfcfPath}

    LvPugrpfcfRootPath="${LvPugrpfcfFile[0]}"
    if [ x"${LvPugrpfcfRootPath}" = x -o ! -e "${LvPugrpfcfRootPath}" ]; then
        eval $1=""
        unset LvPugrpfcfFile
        return
    fi

    
    if [ ${LvPugrpfcfIdx} -lt 2 ]; then
        eval $1="${LvPugrpfcfRootPath}"
        unset LvPugrpfcfFile
        return
    fi
    while [ x"${LvPugrpfcfRootPath}" != x"/" ]; do
        LvPugrpfcfFlag=""
        for (( LvPugrpfcfIndex=0 ; LvPugrpfcfIndex<LvPugrpfcfIdx ; LvPugrpfcfIndex++ )) do
            LvPugrpfcfFlag=$(echo "${LvPugrpfcfFile[LvPugrpfcfIndex]}" | grep -E "${LvPugrpfcfRootPath}")
            if [ x"${LvPugrpfcfFlag}" = x ]; then
                LvPugrpfcfRootPath=$(cd ${LvPugrpfcfRootPath}/..;pwd)
                break; 
            fi
        done
        if [ x"${LvPugrpfcfFlag}" != x ]; then
            break;
        fi
    done
    unset LvPugrpfcfFile
    eval $1="${LvPugrpfcfRootPath}"
    return 
}


## Fn_PathUtils_CheckIfFileIsValid <oResult> <iFile> 
##
## <oResult>   yes="Valid"  no="Invalid"
function Fn_PathUtils_CheckIfFileIsValid()
{
    if [ $# -ne 2 ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPucifivfPath "$2" 
    if [ -z "${LvPucifivfPath}" -o ! -e "${LvPucifivfPath}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because of the invalid path\"${LvPucifivfPath}\""
        exit 0
    fi

    while read LvPucifivfLine; do
        if [ -z "${LvPucifivfLine}" ]; then
            continue
        fi
        if [ -e "${LvPucifivfLine}" -a -f "${LvPucifivfLine}" ]; then
            eval $1="yes"
            unset LvPucifivfLine
            unset LvPucifivfpath
            return
        fi
    done < ${LvPucifivfPath}

    eval $1="no"
    unset LvPucifivfLine
    unset LvPucifivfpath
}



function Fn_Help_Usage()
{
cat >&1 << EOF

[DESCRIPTION]
    Help user to learn about more usage of ${CvScriptName} 

##   << Project Management Topology Architecture V.01 By jielong.lin >>
##
##          |---- ~/.vimide/
##                |
##                |---- ProjectName1
##                |     |---- config
##                |     |
##                |     |---- Java
##                |     |     |---- vimide.filelist
##                |     |     |---- envsetup.sh
##                |     |     |---- envcleanup.sh
##                |     |     |---- tags
##                |     |     |---- cscope.out
##                |     |
##                |     |---- C_C++
##                |     |     |---- vimide.filelist
##                |     |     |---- envsetup.sh
##                |     |     |---- envcleanup.sh
##                |     |     |---- tags
##                |     |     |---- cscope.out
##

[USAGE] 
    ${CvScriptName} help
        Help user to learn about more usage of ${CvScriptName}
        Offer user for that how to use this command.
    
    ${CvScriptName}
        run as Project Managment. The related flowchart as follows:
          [0]...tell vimide what operation to do: to create or delete :
          if create
             [1]...create

        if delete 
        [1]...list all project names and need to select an project to start
        [2]...list all items of the project and need to select 


    ${CvScriptName} --list
    ${CvScriptName} -l
        list all project name

    ${CvScriptName} --create
    ${CvScriptName} -c
        create a project

    ${CvScriptName} --delete
    ${CvScriptName} -d
        delete a project

    ${CvScriptName} --tag <Symbol>
    ${CvScriptName} -t <Symbol>
        jump the <Symbol> in ctags

    ${CvScriptName} --auto

    ${CvScriptName} --update
    ${CvScriptName} -u

    ctrl+]
    ctrl+o
    ctrl+t


EOF
}


#################################################################
#
# VIM IDE
#
#################################################################

if [ $# -eq 0 ]; then
    Fn_Help_Usage
    exit 0
fi

GvVimideFlag=$(which ctags)
if [ -z "${GvVimideFlag}" ]; then
    Lfn_Sys_DbgEcho "Sorry, Please install exuberant-ctags"
    exit 0 
fi
GvVimideFlag=$(which cscope)
if [ -z "${GvVimideFlag}" ]; then
    Lfn_Sys_DbgEcho "Sorry, Please install cscope"
    exit 0 
fi


# Check if the vim IDE environment is valid.
# Verify the vim IDE environment.
GvHome=$(cd ~;pwd)
if [ ! -e "${GvHome}" ]; then
    mkdir -pv ${GvHome}
    chmod 0777 -R ${GvHome}
fi
if [ -e "/media/root/work/jllproject" ]; then
    GvHome="/media/root/work/jllproject"
else
    echo "not exist /media/root/work/jllproject"
    exit 0
fi

GvHome="${GvHome}/.vimide"
if [ ! -e "${GvHome}" ]; then
    mkdir -pv ${GvHome}
    chmod 0777 -R ${GvHome}
fi

# LanguageName  ExuberantCtags  Cscope  FileClasses   
declare -a GvVimIDE_Settings=( 
    "Asm"   "--Asm-kinds=+dlmt"   " "   "*.s *.S *.inc"
    "C"     "--C-kinds=+cdefgmnpstuv"    " "    "*.c *.C *.h"
    "C++"   "--C++-kinds=+cdefgmnpstuv"   " "   "*.cpp *.cc *.CC *.h *.hpp"
    "Java"  "--Java-kinds=+cefgimp --langmap=java:+.aidl"   " "  "*.java *.aidl"
    "Make"  "--Make-kinds=+m"   " "   "*.mak Makefile makefile *.mk"
)

declare -i GvVimIDE_SettingsCount=${#GvVimIDE_Settings[@]}/4

# Prevent "*" from matching all files such as xxx.java is retrieved from matching *.java 
# in current path, hence convert "*" to "\*" 
if [ ${GvVimIDE_SettingsCount} -lt 4 ]; then
    Lfn_Sys_DbgEcho "Sorry, Exit because VimIDE Settings is the invalid table"
    exit 0
fi
for (( GvVimIDE_idx=0 ; GvVimIDE_idx<GvVimIDE_SettingsCount ; GvVimIDE_idx++ )) do
    GvVimIDE_Settings[GvVimIDE_idx*4+3]="${GvVimIDE_Settings[GvVimIDE_idx*4+3]//\*./\\*.}" 
done


##### Testing only for debugging #####
# for (( GvVimIDE_idx=0 ; GvVimIDE_idx<GvVimIDE_SettingsCount ; GvVimIDE_idx++ )) do
#     echo "${GvVimIDE_Settings[GvVimIDE_idx*4+3]}" 
# done
######################################


GvVimIDE_ExuberantCtags_Fields="--fields=+ianmKlS"
GvVimIDE_ExuberantCtags_extra="--extra=+q"
GvVimIDE_CSCOPE_Options="-bkq -i"

# ctags -R --c-kinds=+px --c++-kinds=+px --fields=+iaS --extra=+q -L CollectFileList
# cscope -bkq -i <YourFileList>


## Usage:
##     Fn_vimide_SpecifyProgrammingLanguages <oConfigure> <iOffsetX> <iOffsetY> [<iLanguage>] 
##
## Example.1:
##     Fn_vimide_SpecifyProgrammingLanguages LvVisplChoices 4 5 "Java asm C++ C"
##     echo "YourChoiceProgrammingLanguages: ${LvVisplChoices}"
##   Result.1:
##     Java C++ C
##
## Example.2:
##     Fn_vimide_SpecifyProgrammingLanguages LvVisplChoices 4 5
##     echo "YourChoiceProgrammingLanguages: ${LvVisplChoices}"
function Fn_vimide_SpecifyProgrammingLanguages()
{
    if [ $# -lt 3 -o $# -gt 4 ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    if [ x"$1" = x ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    # Check if parameter is digit and Converse it to a valid parameter 
    echo "$2" | grep -E '[^0-9]' >/dev/null && LvVisplX="0" || LvVisplX="$2";
    echo "$3" | grep -E '[^0-9]' >/dev/null && LvVisplY="0" || LvVisplY="$3";

    LvVisplChoice=""
    if [ x"$4" = x ]; then
        LvVisplFlag=1
        Lfn_Cursor_Mov "${LvVisplY}" "down"
        while [ ${LvVisplFlag} -eq 1 ]; do
            #Lfn_Cursor_Move "1" "$3"
            Lfn_Cursor_Mov "${LvVisplX}" "right"
            echo "=====[ File Type (q: Quit) ]====="
            LvVisplFlag=0
            for (( LvVisplIdx=0 ; LvVisplIdx<GvVimIDE_SettingsCount ; LvVisplIdx++ )) do
                if [ ! -z "${LvVisplChoice}" ]; then
                    for LvVisplItem in ${LvVisplChoice}; do
                        if [ x"${LvVisplItem}" = x"${GvVimIDE_Settings[LvVisplIdx*4]}" ]; then
                            LvVisplItem="Hit.DontDisplay"
                            break
                        fi
                    done
                fi
                if [ x"${LvVisplItem}" = x"Hit.DontDisplay" ]; then
                    continue
                fi
                Lfn_Cursor_Mov "${LvVisplX}" "right" 
                echo "├── ${GvVimIDE_Settings[LvVisplIdx*4]}"
                LvVisplFlag=1
            done
            if [ ${LvVisplFlag} -ne 1 ]; then
                break;
            fi
            Lfn_Cursor_Mov "${LvVisplX}" "right" 
            echo "[Your Choice]   " 
            #read -p "[Your Choice]   "  LvVisplAnChoice
            Lfn_Cursor_Mov "${LvVisplX}" "right" 
            echo "================================="
            Lfn_Cursor_Mov "2" "up"
            Lfn_Cursor_Mov "$(( LvVisplX + 20 ))" "right" 
            read LvVisplAnChoice
            if [ -z "${LvVisplAnChoice}" ]; then
                continue;
            fi
            if [ x"${LvVisplAnChoice}" = x"q" ]; then
                break;
            fi
            for (( LvVisplIdx=0 ; LvVisplIdx<GvVimIDE_SettingsCount ; LvVisplIdx++ )) do
                if [ x"${LvVisplAnChoice}" = x"${GvVimIDE_Settings[LvVisplIdx*4]}" ]; then
                    if [ x"${LvVisplChoice}" != x ]; then
                        # Need to filter repeat the valid choices
                        for LvVisplChoiceEntry in ${LvVisplChoice}; do
                            if [ x"${LvVisplAnChoice}" = x"${LvVisplChoiceEntry}" ]; then
                                break
                            fi
                        done
                        if [ x"${LvVisplAnChoice}" != x"${LvVisplChoiceEntry}" ]; then
                            LvVisplChoice="${LvVisplChoice} ${LvVisplAnChoice}"
                        fi
                        unset LvVisplChoiceEntry
                    else
                        LvVisplChoice="${LvVisplAnChoice}"
                    fi
                fi
            done
        done
    else
        for LvVisplAnChoice in $4; do
            for (( LvVisplIdx=0 ; LvVisplIdx<GvVimIDE_SettingsCount ; LvVisplIdx++ )) do
                if [ x"${LvVisplAnChoice}" = x"${GvVimIDE_Settings[LvVisplIdx*4]}" ]; then
                    LvVisplChoice="${LvVisplChoice} ${LvVisplAnChoice}"
                    break;
                fi
            done
        done
    fi
    
    if [ x"${LvVisplChoice}" = x ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because Dont retrieve any Programming languages"
        exit 0
    fi

    Lfn_Cursor_Mov "${LvVisplX}" "right"
    echo ""
    eval $1=$(echo -e "${LvVisplChoice}" | sed "s:\ :\\\\ :g")
    return
}




## Fn_vimide_LoadSettings <oExuberantCtags> <oCscope> <iLanguage>
##
## For ExuberantCtags, Return the Language Settings to <oExuberantCtags> according to <iLanguage>.
## For Cscope, Return the Language Settings to <oCscope> according to <iLanguage>.
## If failure, it will exit directly.
##
## Example.1:
##     Fn_vimide_LoadSettings LvCtags LvCscope "Java"
##     echo "\"ctags=${LvCtags}\""
##     echo "\"cscope=${LvCscope}\""
##
## Example.2:
##     Fn_vimide_LoadSettings LvCtags LvCscope "Java C++ C"
##     echo "\"ctags=${LvCtags}\""
##     echo "\"cscope=${LvCscope}\""
##
function Fn_vimide_LoadSettings()
{
    if [ $# -ne 3 ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    LvVilsItems1=""
    LvVilsItems2=""
    for (( LvVilsIdx=0 ; LvVilsIdx<GvVimIDE_SettingsCount ; LvVilsIdx++ )) do
      for LvVilsLanguage in $3; do
        if [ x"${GvVimIDE_Settings[LvVilsIdx*4]}" = x"${LvVilsLanguage}" ]; then
            # Exuberant Ctags
            if [ -z "${LvVilsItems1}" ]; then
                LvVilsItems1="${GvVimIDE_Settings[LvVilsIdx*4+1]}"
            else
                LvVilsItems1="${LvVilsItems1} ${GvVimIDE_Settings[LvVilsIdx*4+1]}"
            fi
            # Cscope 
            if [ -z "${LvVilsItems2}" ]; then
                LvVilsItems2="${GvVimIDE_Settings[LvVilsIdx*4+2]}"
            else
                LvVilsItems2="${LvVilsItems2} ${GvVimIDE_Settings[LvVilsIdx*4+2]}"
            fi
 
        fi
      done
    done
 
    # Space is not recognised in the eval command. So it should be transferred.
    if [ ! -z "${LvVilsItems1}" -a  ! -z "${LvVilsItems2}" ]; then
        eval $1=$(echo -e "${LvVilsItems1}" | sed "s:\ :\\\\ :g")
        eval $2=$(echo -e "${LvVilsItems2}" | sed "s:\ :\\\\ :g")
        return 
    fi

    Lfn_Sys_DbgEcho "Sorry, Exit because Dont support for the programming language \"$2\""
    exit 0
}


## Fn_vimide_CollectSourceFiles <iFileListName> <iRootPath> <iLanguage> <iIsDefault> <oRootPath>
##
## Retrieve all <iLanguage> specified files to <iRootPath>/<iFileListName> from 
## path <iRootPath> to each subdirectors. 
##
## if <iIsDefault> is 0, the paths need customer to select.
## if <iIsDefault> is 1, default by selecting all subdirectories. 
##
## Usage:
##     Fn_vimide_CollectSourceFiles "file.list"  "$(pwd)" "Java C++ C Asm Make" 0  oRootPath
##
function Fn_vimide_CollectSourceFiles()
{
    if [ $# -ne 5 -o ! -e "$2" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi
    if [ x"$4" != x"0" -a x"$4" != x"1" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    # collecting the required File Type
    Lfn_Sys_DbgEcho "[Progress] Collecting the required File Types"
    LvVicsfFileType=""
    for (( LvVicsfIdx=0 ; LvVicsfIdx<GvVimIDE_SettingsCount ; LvVicsfIdx++ )) do
        for LvVicsfLanguage in $3; do
            if [ x"${GvVimIDE_Settings[LvVicsfIdx*4]}" = x"${LvVicsfLanguage}" ]; then
                if [ x"${LvVicsfFileType}" = x ]; then
                    LvVicsfFileType="${GvVimIDE_Settings[LvVicsfIdx*4+3]}"
                else
                    LvVicsfFileType="${LvVicsfFileType} ${GvVimIDE_Settings[LvVicsfIdx*4+3]}"
                fi
            fi
        done
    done

    # filtering the same item
    Lfn_Sys_DbgEcho "[Progress] Filterring the same File Types"
    LvVicsfFileTypes=""
    for LvVicsfCurFileType in ${LvVicsfFileType}; do
        if [ -z "${LvVicsfFileTypes}" ]; then
            LvVicsfFileTypes="${LvVicsfCurFileType}"
        else
            for LvVicsfOldFileType in ${LvVicsfFileTypes}; do
                if [ x"${LvVicsfOldFileType}" = x"${LvVicsfCurFileType}" ]; then
                    LvVicsfCurFileType=""
                    break 
                fi
            done
            if [ -z "${LvVicsfCurFileType}" ]; then
                continue
            fi
            LvVicsfFileTypes="${LvVicsfFileTypes} ${LvVicsfCurFileType}"
        fi
    done 

    if [ -z "${LvVicsfFileTypes}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to Dont find any related source files for $3"
        exit 0
    fi

    LvVicsfFindFlags=""
    for LvVicsfItem in ${LvVicsfFileTypes}; do
       if [ -z "${LvVicsfFindFlags}" ]; then
           LvVicsfFindFlags="-name \"${LvVicsfItem//\\*./*.}\" -print"
       else
           LvVicsfFindFlags="${LvVicsfFindFlags} -o -name \"${LvVicsfItem//\\*./*.}\" -print"
       fi
    done
    if [ -z "${LvVicsfFindFlags}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit due to Dont build the matched pattern for $3"
        exit 0
    fi

    # specify the paths of the source files which are added to the project.
    Lfn_Sys_DbgEcho "[Progress] Specify the paths of the source files which are added to the project."
    declare -a LvVicsfPathList
    LvVicsfPathListCount=0
    LvVicsfFindPath="$(cd $2;pwd)"
    if [ x"$4" = x"0" ]; then
        Fn_PathView_UiMain  "${LvVicsfFindPath}" "vimide.path.config" " Path Settings "
        if [ ! -e "$(pwd)/vimide.path.config" ]; then
            Lfn_Sys_DbgEcho "Sorry, Exit because Dont exist \"$(pwd)/vimide.path.config\""
            exit 0
        fi
        #read every file line
        LvVicsfIdx=0
        while read LvVicsfLine; do
            if [ -z "${LvVicsfLine}" ]; then
                continue
            fi
            echo "Line-${LvVicsfIdx}: ${LvVicsfLine}"
            LvVicsfPathList[LvVicsfIdx]="${LvVicsfLine}"
            LvVicsfIdx=$(expr ${LvVicsfIdx} + 1)
        done < $(pwd)/vimide.path.config
        LvVicsfPathListCount="${#LvVicsfPathList[@]}"
        Fn_PathUtils_GetRootPathFromConfigFile LvVicsfRootPath "$(pwd)/vimide.path.config"
        rm -rf $(pwd)/vimide.path.config
    else
        LvVicsfPathList[0]="${LvVicsfFindPath}"
        LvVicsfRootPath="${LvVicsfFindPath}"
        LvVicsfPathListCount=1
    fi

    if [ x"${LvVicsfRootPath}" = x -o ! -e "${LvVicsfRootPath}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because of the invalid Root Path to be retrieved"
        Lfn_Sys_DbgEcho " \"${LvVicsfRootPath}\""
        unset LvVicsfPathList
        exit 0 
    fi
    eval $5="${LvVicsfRootPath}"

    if [ ${LvVicsfPathListCount} -eq 0 ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because Dont specify the customized paths of the source files"
        unset LvVicsfPathList
        exit 0 
    fi

    Lfn_Sys_DbgEcho "[Progress] Collecting all related source files from the followwing paths:"
    if [ -e "${LvVicsfFindPath}/$1" ]; then
        rm -rvf ${LvVicsfFindPath}/$1
    fi
    touch  ${LvVicsfFindPath}/$1
    for (( LvVicsfIdx=0 ; LvVicsfIdx<LvVicsfPathListCount ; LvVicsfIdx++ )) do
        Lfn_Sys_DbgEcho "path.${LvVicsfIdx}:: ${LvVicsfPathList[LvVicsfIdx]}"
        Fn_vimide_Progressbar_MonitorByte "${LvVicsfFindPath}/$1" &
        __CollectSF_BgPid=$!
        eval find ${LvVicsfPathList[LvVicsfIdx]} \
             \\\( -path "${LvVicsfFindPath}/out" -o -path "${LvVicsfFindPath}/jll" \\\) -prune \
             -o -type f \
             -a \\\( ${LvVicsfFindFlags} \\\) >> ${LvVicsfFindPath}/$1
        echo
        kill -12 ${__CollectSF_BgPid} 
    done    

#    eval find ${LvVicsfFindPath} \
#         \\\( -path "${LvVicsfFindPath}/out" -o -path "${LvVicsfFindPath}/jll" \\\) -prune \
#         -o -type f \
#         -a \\\( ${LvVicsfFindFlags} \\\) > ${LvVicsfFindPath}/$1


# \1 specifies the content in \(...\), and append \ before one of " \ ' 
#    sed 's/\(["'\''\]\)/\\\1/g;s/^/"/;s/$/"/' -i ${LvVicsfFindPath}/$1

}



## Fn_vimide_SettingsUtils <oResult> <iSettingsType> <iX> <iY> [<iTitle>]
##
## Please set the FnVimIdeSettingsUtils[] before call Fn_vimide_SettingsUtils
##    The Format of the FnVimIdeSettingsUtils
##      declare -a GvFnVimIdeSettingsUtils=(
##          "YourItemName"
##          "Item1"
##          "Item2"
##      )
##
## <iSettingsType> :
##    "Input"  : input mode
##    "Select" : select mode
## <iX> and <iY> : Start with 1
##
##
## Example:
##     declare -a GvFnVimIdeSettingsUtils=(
##         "YourItemName"
##         "Item1"
##         "Item2"
##         "Item3"
##         "Item4"
##     )
##     Fn_vimide_SettingsUtils oResult  "Select" 7 4 "hello"
##     echo "$oResult"
##     read
##     unset GvFnVimIdeSettingsUtils
##     declare -a GvFnVimIdeSettingsUtils=(
##         "YourItemName"
##         "Item1"
##         "Item2"
##         "Item3"
##     Fn_vimide_SettingsUtils oResult  "Input" 7 4 "hello"
##     echo "$oResult"
##     exit 0
##
function Fn_vimide_SettingsUtils()
{
    if [ $# -gt 5 ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    # Check if parameter is digit and Converse it to a valid parameter 
    echo "$3" | grep -E '[^0-9]' >/dev/null && LvVisuX="0" || LvVisuX="$3";
    if [ x"${LvVisuX}" = x"0" ]; then
        LvVisuX=1
    fi
    echo "$4" | grep -E '[^0-9]' >/dev/null && LvVisuY="0" || LvVisuY="$4";
    if [ x"${LvVisuY}" = x"0" ]; then
        LvVisuY=1
    fi

    # Check if parameter is a valid 
    if [ x"$2" != x"Input" -a x"$2" != x"Select" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi 

    #LvVisuCount=$[${#GvFnVimIdeSettingsUtils[@]} / 2]
    LvVisuCount=$(( ${#GvFnVimIdeSettingsUtils[@]} / 1 ))
    if [ x"$2" = x"Select" -a ${LvVisuCount} -lt 1 ]; then
        # Select Mode but none item to be selected
        echo "Sorry, Cant Run Select Mode Because of None items to be selected."
        return
    fi

    # Select for configuration guide
    LvVisuFocus=99999 #None Focus
    LvVisuNextFocus=0

    while [ 1 ]; do
        ##
        ## Render UI
        ##
        if [ x"$2" = x"Select" ]; then # Input Mode
            Lfn_Cursor_EchoConfig "off"
        fi
        clear
        LvRenderLine=${LvVisuY}
        if [ x"$5" != x ]; then # exist title
            Lfn_Cursor_Move ${LvVisuX} ${LvRenderLine} 
            echo "$5"
            LvRenderLine=$(( LvRenderLine + 1 ))
        fi
        if [ ${LvVisuCount} -gt 0 ]; then
            for (( LvVisuIdx=0 ; LvVisuIdx<LvVisuCount ; LvVisuIdx++ )) do
                if [ x"$2" = x"Select" ]; then
                    Lfn_Cursor_Move ${LvVisuX} ${LvRenderLine} 
                    if [ ${LvVisuFocus} -eq ${LvVisuIdx} ]; then
                        if [ ${LvVisuFocus} -ne ${LvVisuNextFocus} ]; then
                            # Cancel the focus item reversed style
                            echo -ne "├── ${GvFnVimIdeSettingsUtils[LvVisuIdx]}"
                            LvVisuFocus=99999 # lose the focus
                        else
                            # When Focus is the same to Next Focus, such as only exist one item
                            # Echo By Reversing its color 
                            echo -ne "├── ${CvAccOff}\033[07m${GvFnVimIdeSettingsUtils[LvVisuIdx]}${CvAccOff}"
                            LvVisuFocus=${LvVisuNextFocus}
                        fi
                    else
                        if [ ${LvVisuNextFocus} -eq ${LvVisuIdx} ]; then
                            # Echo By Reversing its color 
                            echo -ne "├── ${CvAccOff}\033[07m${GvFnVimIdeSettingsUtils[LvVisuIdx]}${CvAccOff}"
                            LvVisuFocus=${LvVisuNextFocus}
                        else
                            echo -ne "├── ${GvFnVimIdeSettingsUtils[LvVisuIdx]}"
                        fi
                    fi
                    LvRenderLine=$(( LvRenderLine + 1 ))
                fi
                if [ x"$2" = x"Input" ]; then
                    Lfn_Cursor_Move ${LvVisuX} ${LvRenderLine}
                    echo -ne "├── ${GvFnVimIdeSettingsUtils[LvVisuIdx]}"
                    LvRenderLine=$(( LvRenderLine + 1 ))
                fi
            done
            ##
            ## Drive UI
            ##

            if [ x"$2" = x"Select" ]; then
                Lfn_Cursor_Move ${LvVisuX} "$(( LvRenderLine + 4 ))"
                # echo "Focus:${LvVisuFocus} NextFocus:${LvVisuNextFocus} Count:${LvVisuCount}"
                echo "Focus:${LvVisuFocus} Count:${LvVisuCount}"
                Lfn_Stdin_Read LvCustuiData
                case "${LvCustuiData}" in
                "KeyUp"|"k")
                    if [ ${LvVisuNextFocus} -eq 0 ]; then
                        LvVisuNextFocus=${LvVisuCount}
                    fi
                    LvVisuNextFocus=$(expr ${LvVisuNextFocus} - 1)
                ;;
                "KeyDown"|"j")
                    LvVisuNextFocus=$(expr ${LvVisuNextFocus} + 1)
                    if [ ${LvVisuNextFocus} -eq ${LvVisuCount} ]; then
                        LvVisuNextFocus=0
                    fi
                    ;;
                "KeySpaceOrEnter")
                    echo ""
                    LvVisuFocus=${LvVisuNextFocus}
                    Lfn_Cursor_EchoConfig "on"
                    break
                    ;;
                "q")
                    LvVisuFocus=99999
                    echo ""
                    echo "Exit: Quit due to your choice: q"
                    echo ""
                    Lfn_Cursor_EchoConfig "on"
                    exit 0
                    ;;
                *)
                    ;;
                esac
                Lfn_Cursor_EchoConfig "on"
            fi
            if [ x"$2" = x"Input" ]; then
                Lfn_Cursor_Move ${LvVisuX} "$(( LvRenderLine + 1 ))"
                echo "[Please Input A String (Dont repeat name with the above)]"
                Lfn_Cursor_Move ${LvVisuX} "$(( LvRenderLine + 2 ))"
                read LvVisuData
                if [ -z "${LvVisuData}" ]; then
                    echo ""
                    continue
                fi
                if [ x"${LvVisuData}" = x"q" ]; then
                    echo ""
                    echo "Exit: due to your choice: q"
                    echo ""
                    exit 0 
                fi
                LvVisuIsLoop=0
                if [ ${LvVisuCount} -gt 0 ]; then
                    for (( LvVisuIdx=0 ; LvVisuIdx<LvVisuCount ; LvVisuIdx++ )) do
                        if [ x"${GvFnVimIdeSettingsUtils[LvVisuIdx]}" = x"${LvVisuData}" ]; then
                            LvVisuIsLoop=1
                            echo "Sorry, Dont repeat to name the above Items:\"${LvVisuData}\""
                            echo ""
                            break
                        fi
                    done
                fi
                if [ x"${LvVisuIsLoop}" = x"0" -a x"${LvVisuData}" != x ]; then
                    eval $1=$(echo -e "${LvVisuData}" | sed "s:\ :\\\\ :g")
                    unset LvVisuData
                    unset LvVisuIdx
                    unset LvVisuIsLoop
                    break
                fi
            fi
        else
            if [ x"$2" = x"Select" ]; then
                eval $1=""
                return
            fi
            if [ x"$2" = x"Input" ]; then
                Lfn_Cursor_Move ${LvVisuX} "$(( LvRenderLine + 1 ))"
                echo "[Please Input A String (Dont repeat name with the above)]"
                Lfn_Cursor_Move ${LvVisuX} "$(( LvRenderLine + 2 ))"
                read LvVisuData
                echo ""
                if [ x"${LvVisuData}" != x ]; then
                    eval $1="${LvVisuData}"
                    break 
                fi
                if [ x"${LvVisuData}" = x"q" ]; then
                    echo "Exit: due to your choice: q"
                    echo ""
                    break 
                fi
            fi 
        fi
    done

    if [ x"$2" = x"Select" ]; then
        if [ ${LvVisuFocus} -ge 0 -a ${LvVisuFocus} -lt ${LvVisuCount} ]; then
            echo ""
            eval $1=$(echo -e "${GvFnVimIdeSettingsUtils[LvVisuFocus]}" | sed "s:\ :\\\\ :g")
        fi
    fi
 
    unset LvVisuNextFocus
    unset LvVisuFocus
    unset LvVisuCount
}







##------------------------------------------------------##
## Project Management
##------------------------------------------------------##
##
##          |---- ~/.vimide/
##                |
##                |---- ProjectName1
##                |     |---- vimide.filelist
##                |     |---- config
##                |     |
##                |     |---- Java
##                |     |     |---- envsetup.sh
##                |     |     |---- envcleanup.sh
##                |     |     |---- tags
##                |     |     |---- cscope.out
##                |     |
##                |     |---- C_C++
##                |     |     |---- envsetup.sh
##                |     |     |---- envcleanup.sh
##                |     |     |---- tags
##                |     |     |---- cscope.out
##                |     
##                |     
##                |---- ProjectName2
##                |     |---- vimide.filelist
##                |     |---- config
##                |     |
##                |     |---- Asm_Make
##                |     |     |---- envsetup.sh
##                |     |     |---- envcleanup.sh
##                |     |     |---- tags
##                |     |     |---- cscope.out
##                |     |
##                |     |---- Java_C_C++
##                |     |     |---- envsetup.sh
##                |     |     |---- envcleanup.sh
##                |     |     |---- tags
##                |     |     |---- cscope.out
##


###########################
##
## Project Management View
##
###########################



## Usage:
##     Fn_vimide_pm_UiMain_ForUse <iSymbolOrFile> <iFlag>
##
## Settings selector of Project Management View
##     @<iFlag> : 1-Symbol   2-File
##
## Example:
##     Fn_vimide_pm_UiMain_ForUse  "main" 1
##
function Fn_vimide_pm_UiMain_ForUse()
{
    if [ x"$2" != x"1" -a x"$2" != x"2" ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

   # if [ x"$1" != x ]; then
   #     echo "Symbol: $1"
   # fi


    # Check if current path relate to which item in every project
    # maybe the current path equal to the subdirectory specified by config
    LvVipumfuPrjList=$(ls -l ${GvHome} 2>/dev/null | grep -E '^d' | awk -F ' ' '{print $9}')
    if [ ! -z "${LvVipumfuPrjList}" ]; then
        LvVipumfuHitIdx=0
        declare -a LvVipumfuHitPrjs
        declare -a LvVipumfuHitItems
        for LvVipumfuPrjEntry in ${LvVipumfuPrjList}; do
            LvVipumfuItemList=$(ls -l "${GvHome}/${LvVipumfuPrjEntry}" | grep -E '^d' | awk -F ' ' '{print $9}')
            if [ ! -z "${LvVipumfuItemList}" ]; then
                for LvVipumfuItemEntry in ${LvVipumfuItemList}; do
                    if [ -e "${GvHome}/${LvVipumfuPrjEntry}/${LvVipumfuItemEntry}/config" ]; then
                        LvVipumfuTargetPath=$(cat ${GvHome}/${LvVipumfuPrjEntry}/${LvVipumfuItemEntry}/config | grep -E '^/')
                        if [ x"${LvVipumfuTargetPath}" = x ]; then
                            continue
                        fi

                        # Get the Current Path and check if it belongs to which project
                        LvVipumfuPath="$(pwd)"
                        while [ ${#LvVipumfuTargetPath} -le ${#LvVipumfuPath} ]; do
                        #echo "Target( ${LvVipumfuTargetPath} ${#LvVipumfuTargetPath} ) - Current( ${LvVipumfuPath} ${#LvVipumfuPath} )"
                            if [ x"${LvVipumfuTargetPath}" = x"${LvVipumfuPath}" ]; then
                                LvVipumfuHitPrjs[LvVipumfuHitIdx]="${LvVipumfuPrjEntry}"
                                LvVipumfuHitItems[LvVipumfuHitIdx]="${LvVipumfuItemEntry}"
                                LvVipumfuHitIdx=$[ LvVipumfuHitIdx + 1 ]
                                break
                            fi
                            LvVipumfuPath="$(cd ${LvVipumfuPath}/..;pwd)"
                        done
                        unset LvVipumfuPath
                    fi
                done
                unset LvVipumfuItemList
            fi
        done
        unset LvVipumfuPrjList
        if [ ${LvVipumfuHitIdx} -gt 0 ]; then
            unset GvFnVimIdeSettingsUtils
            declare -a GvFnVimIdeSettingsUtils
            for(( LvVipumfuIdx=0 ; LvVipumfuIdx<LvVipumfuHitIdx ; LvVipumfuIdx++ )) do
                LvVipumfuHitEntry="${LvVipumfuHitItems[LvVipumfuIdx]}"
                LvVipumfuHitEntry="${LvVipumfuHitEntry//Dot/\.}"
                LvVipumfuHitEntry="${LvVipumfuHitEntry//PlusPlus/++}"
                LvVipumfuHitEntry="${LvVipumfuHitEntry//_/ }"
  
                GvFnVimIdeSettingsUtils[LvVipumfuIdx]="${LvVipumfuHitPrjs[LvVipumfuIdx]} --- ${LvVipumfuHitEntry}"
            done
            unset LvVipumfuHitEntry
            unset LvVipumfuHitPrjs
            unset LvVipumfuHitItems
 
            Fn_vimide_SettingsUtils LvVipumfuHitMenu  "Select" 7 4 "***** VimIDE: Project Choice Guide *****"
            unset GvFnVimIdeSettingsUtils
            if [ x"${LvVipumfuHitMenu}" = x ]; then
                Lfn_Sys_DbgEcho "Sorry, Exit because of error choice"
                exit 0
            fi
            LvVipumfuMyPrj=$(echo "${LvVipumfuHitMenu}" | awk -F ' --- ' '{print $1}') 
            LvVipumfuMyItem=$(echo "${LvVipumfuHitMenu}" | awk -F ' --- ' '{print $2}')
            LvVipumfuMyItem="${LvVipumfuMyItem/# /}"
            LvVipumfuMyItem="${LvVipumfuMyItem// /_}"
            LvVipumfuMyItem="${LvVipumfuMyItem//++/PlusPlus}"
            LvVipumfuMyItem="${LvVipumfuMyItem//\./Dot}"
            LvVipumfuMyConf="${GvHome}/${LvVipumfuMyPrj}/${LvVipumfuMyItem}"
            if [ ! -e "${LvVipumfuMyConf}" \
                 -o ! -e "${LvVipumfuMyConf}/tags" \
                 -o ! -e "${LvVipumfuMyConf}/cscope.out" \
                 -o ! -e "${LvVipumfuMyConf}/config" \
                 -o ! -e "${LvVipumfuMyConf}/vimide.filelist" \
                 -o ! -e "${LvVipumfuMyConf}/envsetup.sh" \
                 -o ! -e "${LvVipumfuMyConf}/envclean.sh" ]; then
                Lfn_Sys_DbgEcho "Sorry, Exit because \"${LvVipumfuMyConf}\" is a invalid configuration path"
                exit 0
            fi
            echo ""
            tree ${LvVipumfuMyConf} -lh
            echo ""
            source ${LvVipumfuMyConf}/envsetup.sh
            case x"$2" in
            x"1")
                vim -t $1
                ;;
            x"2")
                vim $1
                ;;
            *)
                ;;
            esac
            source ${LvVipumfuMyConf}/envclean.sh
        else
            case x"$2" in
            x"1")
                Lfn_Sys_DbgEcho "Sorry, not open symbol \"$1\" due to lack of vicc project"
                ;;
            x"2")
                vim $1
                ;;
            *)
                ;;
            esac

            unset LvVipumfuHitPrjs
            unset LvVipumfuHitItems
        fi
    fi
}


function Fn_vimide_pm_UiMain_ForUseSymbol()
{
    Fn_vimide_pm_UiMain_ForUse "$1" 1 
}


function Fn_vimide_pm_UiMain_ForUseFile()
{
    Fn_vimide_pm_UiMain_ForUse "$1" 2 
}


function Fn_vimide_pm_UiMain_For_EditNew()
{
    # Check if current path relate to which item in every project
    # maybe the current path equal to the subdirectory specified by config
    LvVipumfuPrjList=$(ls -l ${GvHome} 2>/dev/null | grep -E '^d' | awk -F ' ' '{print $9}')
    if [ ! -z "${LvVipumfuPrjList}" ]; then
        LvVipumfuHitIdx=0
        declare -a LvVipumfuHitPrjs
        declare -a LvVipumfuHitItems
        for LvVipumfuPrjEntry in ${LvVipumfuPrjList}; do
            LvVipumfuItemList=$(ls -l "${GvHome}/${LvVipumfuPrjEntry}" | grep -E '^d' | awk -F ' ' '{print $9}')
            if [ ! -z "${LvVipumfuItemList}" ]; then
                for LvVipumfuItemEntry in ${LvVipumfuItemList}; do
                    if [ -e "${GvHome}/${LvVipumfuPrjEntry}/${LvVipumfuItemEntry}/config" ]; then
                        LvVipumfuTargetPath=$(cat ${GvHome}/${LvVipumfuPrjEntry}/${LvVipumfuItemEntry}/config | grep -E '^/')
                        if [ x"${LvVipumfuTargetPath}" = x ]; then
                            continue
                        fi

                        # Get the Current Path and check if it belongs to which project
                        LvVipumfuPath="$(pwd)"
                        while [ ${#LvVipumfuTargetPath} -le ${#LvVipumfuPath} ]; do
                        #echo "Target( ${LvVipumfuTargetPath} ${#LvVipumfuTargetPath} ) - Current( ${LvVipumfuPath} ${#LvVipumfuPath} )"
                            if [ x"${LvVipumfuTargetPath}" = x"${LvVipumfuPath}" ]; then
                                LvVipumfuHitPrjs[LvVipumfuHitIdx]="${LvVipumfuPrjEntry}"
                                LvVipumfuHitItems[LvVipumfuHitIdx]="${LvVipumfuItemEntry}"
                                LvVipumfuHitIdx=$[ LvVipumfuHitIdx + 1 ]
                                break
                            fi
                            LvVipumfuPath="$(cd ${LvVipumfuPath}/..;pwd)"
                        done
                        unset LvVipumfuPath
                    fi
                done
                unset LvVipumfuItemList
            fi
        done
        unset LvVipumfuPrjList
        if [ ${LvVipumfuHitIdx} -gt 0 ]; then
            unset GvFnVimIdeSettingsUtils
            declare -a GvFnVimIdeSettingsUtils
            for(( LvVipumfuIdx=0 ; LvVipumfuIdx<LvVipumfuHitIdx ; LvVipumfuIdx++ )) do
                LvVipumfuHitEntry="${LvVipumfuHitItems[LvVipumfuIdx]}"
                LvVipumfuHitEntry="${LvVipumfuHitEntry//Dot/\.}"
                LvVipumfuHitEntry="${LvVipumfuHitEntry//PlusPlus/++}"
                LvVipumfuHitEntry="${LvVipumfuHitEntry//_/ }"
  
                GvFnVimIdeSettingsUtils[LvVipumfuIdx]="${LvVipumfuHitPrjs[LvVipumfuIdx]} --- ${LvVipumfuHitEntry}"
            done
            unset LvVipumfuHitEntry
            unset LvVipumfuHitPrjs
            unset LvVipumfuHitItems
 
            Fn_vimide_SettingsUtils LvVipumfuHitMenu  "Select" 7 4 "***** VimIDE: Project Choice Guide *****"
            unset GvFnVimIdeSettingsUtils
            if [ x"${LvVipumfuHitMenu}" = x ]; then
                Lfn_Sys_DbgEcho "Sorry, Exit because of error choice"
                exit 0
            fi
            LvVipumfuMyPrj=$(echo "${LvVipumfuHitMenu}" | awk -F ' --- ' '{print $1}') 
            LvVipumfuMyItem=$(echo "${LvVipumfuHitMenu}" | awk -F ' --- ' '{print $2}')
            LvVipumfuMyItem="${LvVipumfuMyItem/# /}"
            LvVipumfuMyItem="${LvVipumfuMyItem// /_}"
            LvVipumfuMyItem="${LvVipumfuMyItem//++/PlusPlus}"
            LvVipumfuMyItem="${LvVipumfuMyItem//\./Dot}"
            LvVipumfuMyConf="${GvHome}/${LvVipumfuMyPrj}/${LvVipumfuMyItem}"
            if [ ! -e "${LvVipumfuMyConf}" \
                 -o ! -e "${LvVipumfuMyConf}/tags" \
                 -o ! -e "${LvVipumfuMyConf}/cscope.out" \
                 -o ! -e "${LvVipumfuMyConf}/config" \
                 -o ! -e "${LvVipumfuMyConf}/vimide.filelist" \
                 -o ! -e "${LvVipumfuMyConf}/envsetup.sh" \
                 -o ! -e "${LvVipumfuMyConf}/envclean.sh" ]; then
                Lfn_Sys_DbgEcho "Sorry, Exit because \"${LvVipumfuMyConf}\" is a invalid configuration path"
                exit 0
            fi
            echo ""
            tree ${LvVipumfuMyConf}
            echo ""
            source ${LvVipumfuMyConf}/envsetup.sh
            vim $1
            source ${LvVipumfuMyConf}/envclean.sh
        else
            unset LvVipumfuHitPrjs
            unset LvVipumfuHitItems
            vim $1
        fi
    else
        vim $1
    fi
}





## Usage:
##     Fn_vimide_pm_UiMain_ForDel
##
## Settings selector of Project Management View
## ~/.vimide/pm.delete.config will store the result.
##
## Example:
##     Fn_vimide_pm_UiMain_ForDel
##
function Fn_vimide_pm_UiMain_ForDel()
{
#    LvVipumfdPath="$(cd ~/.vimide;pwd)"
    LvVipumfdPath="${GvHome}"
    if [ ! -e "${LvVipumfdPath}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont exist \"${LvVipumfdPath}\""
        exit 0
    fi

#    Fn_PathView_UiMain  "~/.vimide" "pm.delete.config" "dummy"
    Fn_PathView_UiMain  "${LvVipumfdPath}" "pm.delete.config" "dummy"
    if [ ! -e "$(pwd)/pm.delete.config" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because delete operation occurs unknown error."
        unset LvVipumfdPath
        exit 0
    fi
    #mv -f $(pwd)/pm.delete.config ${LvVipumfdPath}/
    while read LvPumfdLine; do
        if [ -z "${LvPumfdLine}" ]; then
            continue
        fi
        # Check if it is path
        if [ ! -e "${LvPumfdLine}" -o ! -d "${LvPumfdLine}" ]; then
            Lfn_Sys_DbgEcho "Sorry, Return because the config file contains an invalid path:"
            Lfn_Sys_DbgEcho " \"${LvPumfdLine}\""
            unset LvPumfdLine
            unset LvVipumfdPath
            return
        fi
        rm -rvf ${LvPumfdLine}
    done < $(pwd)/pm.delete.config
    rm -rvf $(pwd)/pm.delete.config
    unset LvVipumfdPath
}


## Fn_vimide_pm_SpecifyProgrammingLanguages <oResult> <iProjectName> <iOffsetX> <iOffsetY>
##
##     Fn_vimide_pm_SpecifyProgrammingLanguages oResult "test2" 3 4
##
function Fn_vimide_pm_SpecifyProgrammingLanguages()
{
    if [ $# -ne 4 ]; then
       Lfn_Sys_DbgEcho "Sorry, Exit Because of the Error Parameter Count"
       exit 0 
    fi

    # Check if parameter is digit and Converse it to a valid parameter 
    echo "$3" | grep -E '[^0-9]' >/dev/null && LvVipsplX="0" || LvVipsplX="$3";
    echo "$4" | grep -E '[^0-9]' >/dev/null && LvVipsplY="0" || LvVipsplY="$4";

    LvVipsplPrjName="${GvHome}/$2"
#    if [ ! -e "${LvVipsplPrjName}" ]; then
#        Lfn_Sys_DbgEcho "Sorry, Exit Because dont exist the Project \"${LvVipsplPrjName}\""
#        unset LvVipsplPrjName
#        exit 0
#    fi

    declare -a LvVipsplMenu
    declare -i LvVipsplMenuCount=0
    # Scan all items from ~/.vimide/${LvVipsplPrjName}/
    LvVipsplList=$(ls -l ${LvVipsplPrjName} 2>/dev/null | grep -E '^d' | awk -F ' ' '{print $9}')
    if [ ! -z "${LvVipsplList}" ]; then
        #Load the all items to List
        LvVipsplIdx=0
        for LvVipsplEntry in ${LvVipsplList}; do
            LvVipsplEntry="${LvVipsplEntry//Dot/\.}"
            LvVipsplEntry="${LvVipsplEntry//PlusPlus/++}"
            LvVipsplEntry="${LvVipsplEntry//_/ }"
            LvVipsplMenu[LvVipsplIdx]="${LvVipsplEntry}"
            LvVipsplIdx=$(expr ${LvVipsplIdx} + 1)
        done
        LvVipsplMenuCount=${#LvVipsplMenu[@]}
    fi

    if [ ${LvVipsplMenuCount} -gt 0 ]; then
        LvVipsplIsLoop=1
        while [ ${LvVipsplIsLoop} -eq 1 ]; do
            Lfn_Cursor_Mov "${LvVipsplY}" "down"
            # List All Items
            Lfn_Cursor_Mov "$(( ${LvVipsplX} + 0 ))" "right"
            echo "Programming Language List"
            Lfn_Cursor_Mov "$(( ${LvVipsplX} + 0 ))" "right"
            echo "***************************************************"
            Lfn_Cursor_Mov "$(( ${LvVipsplX} + 0 ))" "right"
            echo "*  ├── Project: \"${LvVipsplPrjName}\" "
            for (( LvVipsplIdx=0 ; LvVipsplIdx<LvVipsplMenuCount ; LvVipsplIdx++ )) do
                Lfn_Cursor_Mov "$(( ${LvVipsplX} + 0 ))" "right"
                echo "*      ├── ${LvVipsplIdx}#  ${LvVipsplMenu[LvVipsplIdx]}" 
            done
            Lfn_Cursor_Mov "$(( ${LvVipsplX} + 0 ))" "right"
            echo "***************************************************"
            Fn_vimide_SpecifyProgrammingLanguages LvVipsplProgramLanguages "${LvVipsplX}" "1"
            if [ x"${LvVipsplProgramLanguages}" = x ]; then
                echo ""
                Lfn_Sys_DbgEcho "Sorry, Exit because Dont specify any programming languages"
                exit 0 
            fi
            LvVipsplIsLoop=0
            LvVipsplFlag="no"
            # Verify the Item
            for (( LvVipsplIdx=0 ; LvVipsplIdx<LvVipsplMenuCount ; LvVipsplIdx++ )) do
                LvVipsplSingleFlag="no"
                for LvVipsplMenuEntry in ${LvVipsplMenu[LvVipsplIdx]}; do
                    LvVipsplSingleFlag="no"
                    for LvVipsplLanguageEntry in ${LvVipsplProgramLanguages}; do
                        if [ x"${LvVipsplMenuEntry}" != x"${LvVipsplLanguageEntry}" ]; then
                            continue
                        fi
                        # Next to MenuEntry when current MenuEntry equal to LanguageEntry
                        LvVipsplSingleFlag="yes"
                        break
                    done
                    if [ x"${LvVipsplSingleFlag}" = x"no" ]; then
                        # Travel over Language List, and dont match any language.
                        # So should next to Menu
                        break
                    fi
                done
                if [ x"${LvVipsplSingleFlag}" = x"no" ]; then
                    # Dont find the same in current menu, and it conforms to programming languages select 
                    continue
                fi

                for LvVipsplLanguageEntry in ${LvVipsplProgramLanguages}; do
                    LvVipsplSingleFlag="no"
                    for LvVipsplMenuEntry in ${LvVipsplMenu[LvVipsplIdx]}; do
                        if [ x"${LvVipsplMenuEntry}" != x"${LvVipsplLanguageEntry}" ]; then
                            continue
                        fi
                        LvVipsplSingleFlag="yes"
                        break
                    done
                    if [ x"${LvVipsplSingleFlag}" = x"no" ]; then
                        break
                    fi
                done
                if [ x"${LvVipsplSingleFlag}" = x"no" ]; then
                    # LvVipsplProgramLanguages is the different from LvVipsplMenu[LvVipsplIdx]
                    continue
                fi
                LvVipsplFlag="yes"
                break 
            done
            if [ x"${LvVipsplFlag}" = x"yes" ]; then
                LvVipsplIsLoop=1
                Lfn_Cursor_Mov "$(( LvVipsplX + 0 ))" "right"
                Lfn_Sys_ColorEcho "${CvBgRed}" "${CvFgWhite}"  "Sorry, \"${LvVipsplProgramLanguages}\" has already existed in List."
                Lfn_Cursor_Mov "$(( LvVipsplX + 0 ))" "right"
                Lfn_Sys_ColorEcho "${CvBgRed}" "${CvFgWhite}" "Please re-select Programming Languages"
                echo ""
            fi
        done
    else
        Fn_vimide_SpecifyProgrammingLanguages LvVipsplProgramLanguages "${LvVipsplX}" "1"
        if [ x"${LvVipsplProgramLanguages}" = x ]; then
            echo ""
            Lfn_Sys_DbgEcho "Sorry, Exit because Dont specify any programming languages"
            exit 0
        fi
    fi

    echo "Your Programming Languages: ${LvVipsplProgramLanguages}"
    LvVipsplProgramLanguages=$(echo -e "${LvVipsplProgramLanguages}" | sed "s:\ :\\\\ :g")
    eval $1="${LvVipsplProgramLanguages}"
}


## Fn_vimide_Progressbar_MonitorByte "~/.vimide/mrvl/C_CPlusPlus" &
## GvBgPid=$!
## sleep 20
## echo ""
## kill -12 ${GvBgPid} 
##
function Fn_vimide_Progressbar_MonitorByte()
{
    LvPbInterval=0.05
    LvPbTcount="0"

    if [ $# -ne 1 ]; then
        Lfn_Sys_FuncComment
        exit 0
    fi

    Fn_PathUtils_ConvertToAbsolutePath LvPbPath "$1" 
    if [ -z "${LvPbPath}" -o ! -e "${LvPbPath}" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because of the invalid path\"${LvPbPath}\""
        exit 0
    fi

    export __jllutil_rotate_status=1

    # When SIGUSR2(=12) is received, run "export __jllutil_rotate_status=0" 
    trap "export __jllutil_rotate_status=0"  12

    echo ""
    Lfn_Cursor_Mov "3" "right"
    LvPbOffs=2
    while [ x"${__jllutil_rotate_status}" = x"1" ]; do
        LvPbData="$(du -sh ${LvPbPath} | awk -F ' ' '{print $1}')"
        LvPbTcount=`expr ${LvPbTcount} + 1`
        case  ${LvPbTcount}  in
        1)
            echo -ne "- ${LvPbData}"
            Lfn_Cursor_Mov "$[ ${LvPbOffs}+${#LvPbData} ]" "left"
            sleep  ${LvPbInterval}
        ;;
        2)
            echo -ne "\\ ${LvPbData}"
            Lfn_Cursor_Mov "$[ ${LvPbOffs}+${#LvPbData} ]" "left"
            sleep  ${LvPbInterval}
        ;;
        3)
            echo -ne "| ${LvPbData}"
            Lfn_Cursor_Mov "$[ ${LvPbOffs}+${#LvPbData} ]" "left"
            sleep  ${LvPbInterval}
        ;;
        4)
            echo -ne "/ ${LvPbData}"
            Lfn_Cursor_Mov "$[ ${LvPbOffs}+${#LvPbData} ]" "left"
            sleep  ${LvPbInterval}
        ;;
        *)
            LvPbTcount="0"
            sleep  ${LvPbInterval}
        ;;
        esac
        echo -ne "${CvAccOff}\033[K${CvAccOff}"
    done

    trap 12 # Restore signal SIGUSR2 to default action.
}


## Usage:
##     Fn_vimide_pm_UiMain_ForAdd
##
##
## Example:
##     Fn_vimide_pm_UiMain_ForAdd
##
## Abbreviation: Vipumfa
function Fn_vimide_pm_UiMain_ForAdd()
{
    # Ctrl_c : 3=SIGINT
    # Ctrl_z : 20=SIGTSTP
    # trap "clear;exit 0" 3 20 

    #
    # Menu 
    #
    declare -a GvFnVimIdeSettingsUtils=(
        "Add a new Project"
        "Add a new Item in a Project"
    )
    Fn_vimide_SettingsUtils LvVipumfaMenu  "Select" 7 4 "***** VimIDE: Step 1 - Menu Guide *****"
    if [ x"${LvVipumfaMenu}" = x ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because of error choice"
        exit 0
    fi

    #
    # Scan  ~/.vimide  for retrieving all projects
    #
    unset GvFnVimIdeSettingsUtils
    declare -a GvFnVimIdeSettingsUtils
    LvVipumfaList=$(ls -l ${GvHome} | grep -E '^d' | awk -F ' ' '{print $9}')
    if [ ! -z "${LvVipumfaList}" ]; then
        # Load the all projects to List
        LvVipumfaIdx=0
        for LvVipumfaEntry in ${LvVipumfaList}; do
            GvFnVimIdeSettingsUtils[LvVipumfaIdx]="${LvVipumfaEntry}"
            LvVipumfaIdx=$(( LvVipumfaIdx + 1 ))
        done
    fi
    unset LvVipumfaList
    case "${LvVipumfaMenu}" in
    "Add a new Project")
        Fn_vimide_SettingsUtils LvVipumfaPrj  "Input" 7 4 "***** VimIDE: Step 2 - Add Project Guide *****"
        if [ x"${LvVipumfaPrj}" = x ]; then
            Lfn_Sys_DbgEcho "Sorry, Exit because of error choice"
            exit 0
        fi
    ;;
    "Add a new Item in a Project")
        Fn_vimide_SettingsUtils LvVipumfaPrj  "Select" 7 4 "***** VimIDE: Step 2 - Select Project For Add Item Guide *****"
        if [ x"${LvVipumfaPrj}" = x ]; then
            Lfn_Sys_DbgEcho "Sorry, Exit because of error choice"
            exit 0
        fi
    ;;
    *)
        Lfn_Sys_DbgEcho "Sorry, Exit because of Unknown Error"
        exit 0
    ;;
    esac

    # Create Project Folder
    #mkdir -pv "${GvHome}/${LvVipumfaPrj}"
    #chmod -R 0777 "${GvHome}/${LvVipumfaPrj}"

    #-------------------------------------------------------
    # Set the Programming Language Type for the New Project
    #-------------------------------------------------------
    Fn_vimide_pm_SpecifyProgrammingLanguages LvVipumfaLanguages "${LvVipumfaPrj}" 6 1 
    if [ x"${LvVipumfaLanguages}" = x ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont retrieve the programming languages"
    #    rm -rvf "${GvHome}/${LvVipumfaPrj}"
        unset LvVipumfaPrj
        exit 0
    fi

    #----------------------------------
    # Collect all related source files
    #----------------------------------
    #LvVipumfaHomePath="$(cd ~;pwd)"
    LvVipumfaHomePath="$(pwd)"
    Fn_vimide_CollectSourceFiles "vimide.filelist" "${LvVipumfaHomePath}" "${LvVipumfaLanguages}" 0 LvVipumfaRootPath
    if [ ! -e "${LvVipumfaHomePath}/vimide.filelist" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont exist \"${LvVipumfaHomePath}/vimide.filelist\" "
    #    rm -rvf "${GvHome}/${LvVipumfaPrj}"
        exit 0
    fi
    Fn_PathUtils_CheckIfFileIsValid LvVipumfaIsValid "${LvVipumfaHomePath}/vimide.filelist"
    if [ x"${LvVipumfaIsValid}" = x"no" ]; then
        Lfn_Sys_DbgEcho "Sorry, Exit because dont exist any valid source items in vimide.filelist"
        rm -rvf ${LvVipumfaHomePath}/vimide.filelist
    #    rm -rvf "${GvHome}/${LvVipumfaPrj}"
        exit 0 
    fi

    #-------------------------------------------------------
    # Retrieve the settings for exuberant ctags and cscope
    #-------------------------------------------------------
    Fn_vimide_LoadSettings LvVipumfaCtags LvVipumfaCscope "${LvVipumfaLanguages}"

    #-------------------------------------------------------
    # Dump Detail 
    #-------------------------------------------------------
    echo ""
    echo "===== New Project Detail - Dump View ====="
    echo "├── ProjectName:\"${LvVipumfaPrj}\""
    echo "├── ProjectRoot:\"${LvVipumfaRootPath}\""
    echo "├── ProgrammingLanguages:\"${LvVipumfaLanguages}\""
    echo "├── SourceFiles:\"${LvVipumfaHomePath}/vimide.filelist\""
    echo "├── ExuberantCtags:\"${LvVipumfaCtags}\""
    echo "└── CSCOPE:\"${LvVipumfaCscope}\""
    echo ""
    # Convert some characters to conform to folder name
    LvVipumfaLanguages="${LvVipumfaLanguages/# /}"
    LvVipumfaLanguages="${LvVipumfaLanguages// /_}"
    LvVipumfaLanguages="${LvVipumfaLanguages//++/PlusPlus}"
    LvVipumfaLanguages="${LvVipumfaLanguages//\./Dot}"
    echo "===== Topology View ====="
    echo "├── Root=\"${GvHome}\""
    echo "│   ├── Project=\"${LvVipumfaPrj}\""
    echo "│   │   ├── Language=\"${LvVipumfaLanguages}\""
    echo "│   │   │   ├── vimide.filelist"
    echo "│   │   │   ├── config"
    echo "│   │   │   ├── tags"
    echo "│   │   │   ├── cscope.out"
    echo "│   │   │   ├── envsetup.sh"
    echo "│   │   │   ├── envclean.sh"
    echo ""
    #echo "Do you confirm to create the above new project:\"${LvVipumfaPrj}\" if [y]?  "
    #read -s -n 1 LvVipumfaChoice
    LvVipumfaChoice="y"
    if [ x"${LvVipumfaChoice}" != x"y" ]; then
        echo ""
        echo "Dont create this new project:\"${LvVipumfaPrj}\" because of Cancel"
        rm -rvf ${LvVipumfaHomePath}/vimide.filelist
    #    rm -rvf "${GvHome}/${LvVipumfaPrj}"
    else
        # Create a new item for the project 
        if [ ! -e "${GvHome}/${LvVipumfaPrj}" ]; then
            mkdir -pv ${GvHome}/${LvVipumfaPrj}
            chmod -R 0777 ${GvHome}/${LvVipumfaPrj}
        fi
        if [ ! -e "${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}" ]; then
            mkdir -pv ${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}
            chmod -R 0777 ${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}
        fi
        echo "${LvVipumfaRootPath}" > ${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}/config
        mv -vf ${LvVipumfaHomePath}/vimide.filelist ${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}
        cd ${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}
        echo ""
        echo "=====> Build exuberant-ctags database "
        Fn_vimide_Progressbar_MonitorByte "${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}" &
        LvVipumfaBgPid=$!
        ctags -R ${LvVipumfaCtags} ${GvVimIDE_ExuberantCtags_Fields} ${GvVimIDE_ExuberantCtags_extra} -L vimide.filelist
        echo ""
        kill -12 ${LvVipumfaBgPid} 

        # convert the vimide.filelist to support for the path with space 
        sed 's/^\|$/"/g' -i vimide.filelist
        echo ""
        echo "=====> Build cscope database "
        Fn_vimide_Progressbar_MonitorByte "${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}" &
        LvVipumfaBgPid=$!
        cscope  ${GvVimIDE_CSCOPE_Options} vimide.filelist
        echo ""
        kill -12 ${LvVipumfaBgPid} 

        #sed 's/"//g' -i vimide.filelist

        #
        # generate the environment script
        #
cat > envsetup.sh << EOF
#!/bin/bash
# Copyright (c) 2016-2100.  jielong_lin.  All rights reserved.
# This file is generated automatically by vicc.

export tags=${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}/tags
export CSCOPE_DB=${GvHome}/${LvVipumfaPrj}/${LvVipumfaLanguages}/cscope.out

EOF
chmod 0777 envsetup.sh

cat > envclean.sh << EOF
#!/bin/bash
# Copyright (c) 2016-2100.  jielong_lin.  All rights reserved.
# This file is generated automatically by vicc.

#tags=
#CSCOPE_DB=

[ x"\${tags}" != x ] && unset tags
[ x"\${CSCOPE_DB}" != x ] && unset CSCOPE_DB

EOF
chmod 0777 envclean.sh

        cd -  >/dev/null
    fi
}

# Rebuilt the project but its subdirectories of the root directory will be used.
# Arguments:  [auto/select]
function Fn_vimide_pm_UiMain_ForRebuild()
{
    if [ x"$1" = x ]; then
        echo
        echo  "JLL-VICC:  Fatal Error because not obey function prototype."
        echo
        exit 0
    fi

    if [ x"$1" != x"auto" -a x"$1" != x"select" ]; then
        echo
        echo  "JLL-VICC:  Fatal Error because Arguments must be 'all' or 'select'."
        echo
        exit 0
    fi

    # Check if current path relate to which item in every project
    # maybe the current path equal to the subdirectory specified by config
    LvVipumfrPrjList=$(ls -l ${GvHome} 2>/dev/null | grep -E '^d' | awk -F ' ' '{print $9}')
    if [ ! -z "${LvVipumfrPrjList}" ]; then
        LvVipumfrHitIdx=0
        declare -a LvVipumfrHitPrjs
        declare -a LvVipumfrHitItems
        for LvVipumfrPrjEntry in ${LvVipumfrPrjList}; do
            LvVipumfrItemList=$(ls -l "${GvHome}/${LvVipumfrPrjEntry}" 2>/dev/null | grep -E '^d' | awk -F ' ' '{print $9}')
            if [ ! -z "${LvVipumfrItemList}" ]; then
                for LvVipumfrItemEntry in ${LvVipumfrItemList}; do
                    if [ -e "${GvHome}/${LvVipumfrPrjEntry}/${LvVipumfrItemEntry}/config" ]; then
                        LvVipumfrTargetPath=$(cat ${GvHome}/${LvVipumfrPrjEntry}/${LvVipumfrItemEntry}/config | grep -E '^/')
                        if [ x"${LvVipumfrTargetPath}" = x ]; then
                            continue
                        fi

                        # Get the Current Path and check if it belongs to which project
                        LvVipumfrPath="$(pwd)"
                        while [ ${#LvVipumfrTargetPath} -le ${#LvVipumfrPath} ]; do
                        # echo "Target( ${LvVipumfrTargetPath} ${#LvVipumfrTargetPath} )"
                        # echo "--- Current( ${LvVipumfrPath} ${#LvVipumfrPath} )"
                            if [ x"${LvVipumfrTargetPath}" = x"${LvVipumfrPath}" ]; then
                                LvVipumfrHitPrjs[LvVipumfrHitIdx]="${LvVipumfrPrjEntry}"
                                LvVipumfrHitItems[LvVipumfrHitIdx]="${LvVipumfrItemEntry}"
                                LvVipumfrHitIdx=$[ LvVipumfrHitIdx + 1 ]
                                break
                            fi
                            LvVipumfrPath="$(cd ${LvVipumfrPath}/..;pwd)"
                        done
                        unset LvVipumfrPath
                    fi
                done
                unset LvVipumfrItemList
            fi
        done
        unset LvVipumfrPrjList

        if [ ${LvVipumfrHitIdx} -gt 0 ]; then
            unset GvFnVimIdeSettingsUtils
            declare -a GvFnVimIdeSettingsUtils
 
            for(( LvVipumfrIdx=0 ; LvVipumfrIdx<LvVipumfrHitIdx ; LvVipumfrIdx++ )) do
                LvVipumfrHitEntry="${LvVipumfrHitItems[LvVipumfrIdx]}"
                LvVipumfrHitEntry="${LvVipumfrHitEntry//Dot/\.}"
                LvVipumfrHitEntry="${LvVipumfrHitEntry//PlusPlus/++}"
                LvVipumfrHitEntry="${LvVipumfrHitEntry//_/ }"
  
                GvFnVimIdeSettingsUtils[LvVipumfrIdx]="${LvVipumfrHitPrjs[LvVipumfrIdx]} --- ${LvVipumfrHitEntry}"
            done
            unset LvVipumfrHitEntry
            unset LvVipumfrHitPrjs
            unset LvVipumfrHitItems
 
            LvVipumfrCount=$(( ${#GvFnVimIdeSettingsUtils[@]} / 1 ))
            if [ ${LvVipumfrCount} -lt 1 ]; then
                echo "Sorry, Exit because None items is associated with this path."
                unset GvFnVimIdeSettingsUtils
                exit 0
            fi
            for(( LvVipumfrIdx=0 ; LvVipumfrIdx<LvVipumfrCount ; LvVipumfrIdx++ )) do
                if [ x"$1" = x"select" ]; then
                    Fn_vimide_SettingsUtils LvVipumfrHitMenu  "Select" 7 4 "VICC Menu: PROJECT---ITEMS (q: Quit)"
                else  # $1="auto"
                    LvVipumfrHitMenu="${GvFnVimIdeSettingsUtils[LvVipumfrIdx]}"
                fi
                if [ x"${LvVipumfrHitMenu}" = x ]; then
                    continue
                fi
                LvVipumfrMyPrj=$(echo "${LvVipumfrHitMenu}" | awk -F ' --- ' '{print $1}') 
                LvVipumfrMyItem=$(echo "${LvVipumfrHitMenu}" | awk -F ' --- ' '{print $2}')
                LvVipumfrMyItemName="${LvVipumfrMyItem/# /}"
                LvVipumfrMyItemName="${LvVipumfrMyItemName// /_}"
                LvVipumfrMyItemName="${LvVipumfrMyItemName//++/PlusPlus}"
                LvVipumfrMyItemName="${LvVipumfrMyItemName//\./Dot}"
                LvVipumfrMyConf="${GvHome}/${LvVipumfrMyPrj}/${LvVipumfrMyItemName}"
                if [ ! -e "${LvVipumfrMyConf}" \
                    -o ! -e "${LvVipumfrMyConf}/tags" \
                    -o ! -e "${LvVipumfrMyConf}/cscope.out" \
                    -o ! -e "${LvVipumfrMyConf}/config" \
                    -o ! -e "${LvVipumfrMyConf}/vimide.filelist" \
                    -o ! -e "${LvVipumfrMyConf}/envsetup.sh" \
                    -o ! -e "${LvVipumfrMyConf}/envclean.sh" ]; then
                    continue
                fi

                #----------------------------------
                # re-Collect all related source files
                # Default by all-subdirectories in 
                # project root path
                #----------------------------------
                LvVipumfrRootPath="$(cat ${LvVipumfrMyConf}/config | grep -E '^/')"
                Fn_vimide_CollectSourceFiles "vimide.filelist" "${LvVipumfrRootPath}" "${LvVipumfrMyItem}" 1 LvVipumfrNewRootPath
                if [ ! -e "${LvVipumfrRootPath}/vimide.filelist" ]; then
                    Lfn_Sys_DbgEcho "Sorry, Exit because dont exist \"${LvVipumfrRootPath}/vimide.filelist\" "
                    exit 0
                fi
                Fn_PathUtils_CheckIfFileIsValid LvVipumfrIsValid "${LvVipumfrRootPath}/vimide.filelist"
                if [ x"${LvVipumfrIsValid}" = x"no" ]; then
                    Lfn_Sys_DbgEcho "Sorry, Exit because dont exist any valid source items in vimide.filelist"
                    rm -rvf ${LvVipumfrRootPath}/vimide.filelist
                    exit 0 
                fi

                #-------------------------------------------------------
                # Retrieve the settings for exuberant ctags and cscope
                #-------------------------------------------------------
                Fn_vimide_LoadSettings LvVipumfrCtags LvVipumfrCscope "${LvVipumfrMyItem}"

                #-------------------------------------------------------
                # Dump Detail 
                #-------------------------------------------------------
                echo ""
                echo "===== ${LvVipumfrMyPrj} ====="
                echo "├── ProjectName:\"${LvVipumfrMyPrj}\""
                echo "├── ProgrammingLanguages=\"${LvVipumfrMyItem}\""
                echo "├── ExuberantCtags=\"${LvVipumfrCtags}\""
                echo "├── CSCOPE=\"${LvVipumfrCscope}\""
                echo "└── ProjectRoot=\"$(cat ${LvVipumfrMyConf}/config | grep -E '^/')\""
                echo "    └── ${LvVipumfrMyItemName}"
                echo "        ├── config"
                echo "        ├── vimide.filelist"
                echo "        ├── tags"
                echo "        ├── cscope.out"
                echo "        ├── envsetup.sh"
                echo "        └── envclean.sh"
                echo ""

                echo "${LvVipumfrRootPath}" > ${LvVipumfrMyConf}/config
                mv -vf ${LvVipumfrRootPath}/vimide.filelist ${LvVipumfrMyConf}

                cd ${LvVipumfrMyConf}
                echo ""
                echo "=====> Build exuberant-ctags database "
                Fn_vimide_Progressbar_MonitorByte "${LvVipumfrMyConf}" &
                LvVipumfrBgPid=$!
                ctags -R ${LvVipumfrCtags} ${GvVimIDE_ExuberantCtags_Fields} ${GvVimIDE_ExuberantCtags_extra} -L vimide.filelist
                echo ""
                kill -12 ${LvVipumfrBgPid} 

                # convert the vimide.filelist to support for the path with space 
                sed 's/^\|$/"/g' -i vimide.filelist
                echo ""
                echo "=====> Build cscope database "
                Fn_vimide_Progressbar_MonitorByte "${LvVipumfrMyConf}" &
                LvVipumfrBgPid=$!
                cscope ${LvVipumfrCscope} ${GvVimIDE_CSCOPE_Options} vimide.filelist
                echo ""
                kill -12 ${LvVipumfrBgPid} 

                #sed 's/"//g' -i vimide.filelist

cat > envsetup.sh << EOF
#!/bin/bash
# Copyright (c) 2016-2100.  jielong_lin.  All rights reserved.
# This file is generated automatically by vicc.

export tags=${LvVipumfrMyConf}/tags
export CSCOPE_DB=${LvVipumfrMyConf}/cscope.out

EOF
chmod 0777 envsetup.sh

cat > envclean.sh << EOF
#!/bin/bash
# Copyright (c) 2016-2100.  jielong_lin.  All rights reserved.
# This file is generated automatically by vicc.

#tags=
#CSCOPE_DB=

[ x"\${tags}" != x ] && unset tags
[ x"\${CSCOPE_DB}" != x ] && unset CSCOPE_DB

EOF
chmod 0777 envclean.sh

                cd - >/dev/null
                if [ x"$1" = x"select" ]; then
                    break
                fi
            done
            unset GvFnVimIdeSettingsUtils
            exit 0
        fi
    fi
}

# List all projects associated with the current path
function Fn_vimide_pm_UiMain_ForProjectList()
{
    # Check if current path relate to which item in every project
    # maybe the current path equal to the subdirectory specified by config
    LvVipumfrPrjList=$(ls -l ${GvHome} 2>/dev/null | grep -E '^d' | awk -F ' ' '{print $9}')
    if [ ! -z "${LvVipumfrPrjList}" ]; then
        LvVipumfrHitIdx=0
        declare -a LvVipumfrHitPrjs
        declare -a LvVipumfrHitItems
        for LvVipumfrPrjEntry in ${LvVipumfrPrjList}; do
            LvVipumfrItemList=$(ls -l "${GvHome}/${LvVipumfrPrjEntry}" | grep -E '^d' | awk -F ' ' '{print $9}')
            if [ ! -z "${LvVipumfrItemList}" ]; then
                for LvVipumfrItemEntry in ${LvVipumfrItemList}; do
                    if [ -e "${GvHome}/${LvVipumfrPrjEntry}/${LvVipumfrItemEntry}/config" ]; then
                        LvVipumfrTargetPath=$(cat ${GvHome}/${LvVipumfrPrjEntry}/${LvVipumfrItemEntry}/config | grep -E '^/')
                        if [ x"${LvVipumfrTargetPath}" = x ]; then
                            continue
                        fi

                        # Get the Current Path and check if it belongs to which project
                        LvVipumfrPath="$(pwd)"
                        while [ ${#LvVipumfrTargetPath} -le ${#LvVipumfrPath} ]; do
                        #echo "Target( ${LvVipumfrTargetPath} ${#LvVipumfrTargetPath} ) - Current( ${LvVipumfrPath} ${#LvVipumfrPath} )"
                            if [ x"${LvVipumfrTargetPath}" = x"${LvVipumfrPath}" ]; then
                                LvVipumfrHitPrjs[LvVipumfrHitIdx]="${LvVipumfrPrjEntry}"
                                LvVipumfrHitItems[LvVipumfrHitIdx]="${LvVipumfrItemEntry}"
                                LvVipumfrHitIdx=$[ LvVipumfrHitIdx + 1 ]
                                break
                            fi
                            LvVipumfrPath="$(cd ${LvVipumfrPath}/..;pwd)"
                        done
                        unset LvVipumfrPath
                    fi
                done
                unset LvVipumfrItemList
            fi
        done
        if [ ${LvVipumfrHitIdx} -gt 0 ]; then
            unset LvVipumfrPrjList
            unset GvFnVimIdeSettingsUtils
            declare -a GvFnVimIdeSettingsUtils
            for(( LvVipumfrIdx=0 ; LvVipumfrIdx<LvVipumfrHitIdx ; LvVipumfrIdx++ )) do
                LvVipumfrHitEntry="${LvVipumfrHitItems[LvVipumfrIdx]}"
                LvVipumfrHitEntry="${LvVipumfrHitEntry//Dot/\.}"
                LvVipumfrHitEntry="${LvVipumfrHitEntry//PlusPlus/++}"
                LvVipumfrHitEntry="${LvVipumfrHitEntry//_/ }"
  
                GvFnVimIdeSettingsUtils[LvVipumfrIdx]="${LvVipumfrHitPrjs[LvVipumfrIdx]} --- ${LvVipumfrHitEntry}"
            done
            unset LvVipumfrHitEntry
            unset LvVipumfrHitPrjs
            unset LvVipumfrHitItems
 
            LvVipumfrCount=$(( ${#GvFnVimIdeSettingsUtils[@]} / 1 ))
            if [ ${LvVipumfrCount} -lt 1 ]; then
                echo "Sorry, Exit because None items is associated with this path."
                unset GvFnVimIdeSettingsUtils
                exit 0
            fi
            for(( LvVipumfrIdx=0 ; LvVipumfrIdx<LvVipumfrCount ; LvVipumfrIdx++ )) do
                LvVipumfrHitMenu="${GvFnVimIdeSettingsUtils[LvVipumfrIdx]}"
                if [ x"${LvVipumfrHitMenu}" = x ]; then
                    continue
                fi
                LvVipumfrMyPrj=$(echo "${LvVipumfrHitMenu}" | awk -F ' --- ' '{print $1}') 
                LvVipumfrMyItem=$(echo "${LvVipumfrHitMenu}" | awk -F ' --- ' '{print $2}')
                LvVipumfrMyItemName="${LvVipumfrMyItem/# /}"
                LvVipumfrMyItemName="${LvVipumfrMyItemName// /_}"
                LvVipumfrMyItemName="${LvVipumfrMyItemName//++/PlusPlus}"
                LvVipumfrMyItemName="${LvVipumfrMyItemName//\./Dot}"
                LvVipumfrMyConf="${GvHome}/${LvVipumfrMyPrj}/${LvVipumfrMyItemName}"
                if [ ! -e "${LvVipumfrMyConf}" \
                    -o ! -e "${LvVipumfrMyConf}/tags" \
                    -o ! -e "${LvVipumfrMyConf}/cscope.out" \
                    -o ! -e "${LvVipumfrMyConf}/config" \
                    -o ! -e "${LvVipumfrMyConf}/vimide.filelist" \
                    -o ! -e "${LvVipumfrMyConf}/envsetup.sh" \
                    -o ! -e "${LvVipumfrMyConf}/envclean.sh" ]; then
                    continue
                fi

                #-------------------------------------------------------
                # Retrieve the settings for exuberant ctags and cscope
                #-------------------------------------------------------
                Fn_vimide_LoadSettings LvVipumfrCtags LvVipumfrCscope "${LvVipumfrMyItem}"

                #-------------------------------------------------------
                # Dump Detail 
                #-------------------------------------------------------
                echo ""
                echo "===== ${LvVipumfrMyPrj} ====="
                echo "├── ProjectName:\"${LvVipumfrMyPrj}\""
                echo "├── ProgrammingLanguages=\"${LvVipumfrMyItem}\""
                echo "├── ExuberantCtags=\"${LvVipumfrCtags}\""
                echo "├── CSCOPE=\"${LvVipumfrCscope}\""
                echo "└── ProjectRoot=\"$(cat ${LvVipumfrMyConf}/config | grep -E '^/')\""
                echo "    └── ${LvVipumfrMyItemName}"
                echo "        ├── config"
                echo "        ├── vimide.filelist"
                echo "        ├── tags"
                echo "        ├── cscope.out"
                echo "        ├── envsetup.sh"
                echo "        └── envclean.sh"
                echo ""

            done
            unset LvVipumfrMyPrj
            unset LvVipumfrMyItem
            unset LvVipumfrMyItemName
            unset LvVipumfrMyConf
            unset LvVipumfrCtags
            unset LvVipumfrCscope
            unset LvVipumfrItemList
            unset LvVipumfrPrjList
            unset GvFnVimIdeSettingsUtils
            exit 0
        fi


        # Want to know all projects details
        for LvVipumfrPrjEntry in ${LvVipumfrPrjList}; do
            LvVipumfrItemList=$(ls -l "${GvHome}/${LvVipumfrPrjEntry}" | grep -E '^d' | awk -F ' ' '{print $9}')
            if [ -z "${LvVipumfrItemList}" ]; then
                continue
            fi
            LvVipumfrMyPrj="${LvVipumfrPrjEntry}"
            for LvVipumfrItemEntry in ${LvVipumfrItemList}; do
                LvVipumfrMyItemName="${LvVipumfrItemEntry}"
                LvVipumfrMyConf="${GvHome}/${LvVipumfrMyPrj}/${LvVipumfrMyItemName}"
                if [ ! -e "${LvVipumfrMyConf}" \
                    -o ! -e "${LvVipumfrMyConf}/tags" \
                    -o ! -e "${LvVipumfrMyConf}/cscope.out" \
                    -o ! -e "${LvVipumfrMyConf}/config" \
                    -o ! -e "${LvVipumfrMyConf}/vimide.filelist" \
                    -o ! -e "${LvVipumfrMyConf}/envsetup.sh" \
                    -o ! -e "${LvVipumfrMyConf}/envclean.sh" ]; then
                    continue
                fi

                LvVipumfrMyItem="${LvVipumfrMyItemName//Dot/\.}"
                LvVipumfrMyItem="${LvVipumfrMyItem//PlusPlus/++}"
                LvVipumfrMyItem="${LvVipumfrMyItem//_/ }"

                #-------------------------------------------------------
                # Retrieve the settings for exuberant ctags and cscope
                #-------------------------------------------------------
                Fn_vimide_LoadSettings LvVipumfrCtags LvVipumfrCscope "${LvVipumfrMyItem}"

                #-------------------------------------------------------
                # Dump Detail 
                #-------------------------------------------------------
                echo ""
                echo "===== ${LvVipumfrMyPrj} ====="
                echo "├── ProjectName:\"${LvVipumfrMyPrj}\""
                echo "├── ProgrammingLanguages=\"${LvVipumfrMyItem}\""
                echo "├── ExuberantCtags=\"${LvVipumfrCtags}\""
                echo "├── CSCOPE=\"${LvVipumfrCscope}\""
                echo "└── ProjectRoot=\"$(cat ${LvVipumfrMyConf}/config | grep -E '^/')\""
                echo "    └── ${LvVipumfrMyItemName}"
                echo "        ├── config"
                echo "        ├── vimide.filelist"
                echo "        ├── tags"
                echo "        ├── cscope.out"
                echo "        ├── envsetup.sh"
                echo "        └── envclean.sh"
                echo "" 
            done 
        done
        unset LvVipumfrMyPrj
        unset LvVipumfrMyItem
        unset LvVipumfrMyItemName
        unset LvVipumfrMyConf
        unset LvVipumfrCtags
        unset LvVipumfrCscope
        unset LvVipumfrItemList
        unset LvVipumfrPrjList
    fi
}




if [ $# -eq 0 ]; then
Fn_vimide_pm_UiMain_For_EditNew
exit 0
fi



# --list | -l
# # list all project name
# --create | -c
# # create a project
# --delete | -d
# # delete a project
# --tag <Symbol> | -t <Symbol>
# # jump the <Symbol> in ctags
#
GvCmdState=0
GvArg1=""
GvArg2=""
for ac_arg; do
    case $ac_arg in
        --list|-l)
            #tree ~/.vimide/
            Fn_vimide_pm_UiMain_ForProjectList
            exit 0
            ;;
        --create|-c)
            echo "ac_arg: $ac_arg"
            GvCmdState=1
            Fn_vimide_pm_UiMain_ForAdd
            exit 0
            ;;
        --delete|-d)
            echo "ac_arg: $ac_arg"
            GvCmdState=2
            Fn_vimide_pm_UiMain_ForDel
            exit 0
            ;;
        --auto)
            echo "auto"
            Fn_vimide_pm_UiMain_ForRebuild "auto"
            exit 0
            ;;
        --update|-u)
            echo "update"
            Fn_vimide_pm_UiMain_ForRebuild "select"
            exit 0
            ;;
        --tag|-t)
            echo "ac_arg: $ac_arg"
            GvCmdState=3
            ;;
        *)
            if [ x"${GvCmdState}" != x"1" \
                 -a x"${GvCmdState}" != x"2" \
                 -a x"${GvCmdState}" != x"3" \
                 -a x"${ac_arg}" != x ]; then
                Fn_PathUtils_ConvertToAbsolutePath GvArg1 "${ac_arg}"
                if [ ! -e "${GvArg1}" -o ! -f "${GvArg1}" ]; then
                    GvArg1=""
                else
                    Fn_vimide_pm_UiMain_ForUseFile "${GvArg1}"
                    exit 0 
                fi 
            fi

            case ${GvCmdState} in
                0) #New file edit
                    Fn_vimide_pm_UiMain_For_EditNew "${ac_arg}"
                    exit 0
                    ;;
                3) #jump to the specified symbol
                    if [ x"${GvArg1}" = x ]; then
                        GvArg1="${ac_arg}"
                        Fn_vimide_pm_UiMain_ForUseSymbol "${GvArg1}"
                        exit 0 
                    fi
                    ;;
                *)
                    Fn_Help_Usage
                    exit 0
                    ;;
            esac
            ;;
    esac
done


Fn_Help_Usage
exit 0
####################################################################
#  Copyright (c) 2015.  lin_jie_long@126.com,  All rights reserved.
####################################################################


